
'''
websockets 14 æ¿ä»¥ä¸Šæœ‰ç›¸å®¹æ€§å•é¡Œ
pip uninstall websockets -y
pip install websockets==13.1
pip show websockets
'''

'''
2025/0x/xx  Roy Ching    æ”¯æ´ GCE.
2025/03/03  Roy Ching    å‚³é€è‡³ sever ä¹‹ call_num ç”± string æ”¹ç‚º int.
2025/03/24  Roy Ching    æ”¯æ´ GCR & GCE.
2025/04/01  Roy Ching    æ”¯æ´ get.
2025/04/07  Roy Ching    æ”¯æ´å¯†ç¢¼ç™»éŒ„.
2025/04/08  Roy Ching    åŠ å…¥å¯†ç¢¼ç™»éŒ„é©—è­‰å°ä¸Šé‡è©¦æ©Ÿåˆ¶.
2025/04/09  Roy Ching    ä¿®æ­£loginå¾Œgetä¸åˆ°ç›®å‰çš„è™Ÿç¢¼å•é¡Œ.
2025/04/10  Roy Ching    ä¿®æ­£ç™»å…¥å¾Œå¾0é–‹å§‹å•é¡Œ.
2025/04/14  Roy Ching    åŠ å…¥å«è™Ÿè³‡æ–™æ›´æ–°é€šçŸ¥ (update)åŠŸèƒ½.
2025/04/15  Roy Ching    ä¿®å¾©æ–·ç·šé‡é€£å¾Œå«è™Ÿè³‡æ–™æ›´æ–°é€šçŸ¥å¤±æ•ˆå•é¡Œ(add_connection) (2025/04/16 å–æ¶ˆ).
2025/04/16  Roy Ching    æ–·ç·šé‡é€£éœ€è¦è¡æ–°èªè­‰(auth).
2025/04/16  Roy Ching    åŠ å…¥ 'get_num_info' åŠ 'info' å‘¼å«æ”¯æ´
2025/04/17  Roy Ching    ä¿®å¾©æ–·ç·šé‡é€£è™Ÿç¢¼æ­¸é›¶å•é¡Œ.
2025/04/17  Roy Ching    æ”¯æ´ get_num_info æ–°èˆŠè¦æ ¼
2025/04/18  Roy Ching    handle_auth åŠ  auth_lock:
2025/04/22  Roy Ching    æ–·ç·šæ™‚é–“ 0~9 æ”¹ 1~10
2025/04/25  Roy Ching    åŠ å…¥ LockWithNotification & TracedLock
2025/04/28  Roy Ching    ä¿®æ­£ CMB Caller ç™»å…¥éŒ¯èª¤å•é¡Œ
2025/05/02  Roy Ching    auth_lock æ”¹ç‚º ws_cmd_lock
2025/05/02  Roy Ching    å¢åŠ  new_get_num å‘½ä»¤.
2025/05/02  Roy Ching    auth å‘½ä»¤ å¢åŠ  "user_get_num" ç™»å…¥, å¢åŠ  wait_time_avgã€new_get_numã€get_num_switchåŠuser_get_num å‘½ä»¤.
2025/05/02  Roy Ching    get_num_switch å¢åŠ ä¸»å‹•é€šçŸ¥åŠŸèƒ½, user_get_num å¢åŠ  "user_id" æ¬„ä½, å¢åŠ  get_num_status å‘½ä»¤.
2025/05/06  Roy Ching    æ”¹ç‚ºä¸»å‹•é€šçŸ¥ user_get_num
2025/05/06  Roy Ching    user_get_num è‡ªå‹•ç™»å…¥_XXXXXXXXXXXXXXXXXX
'''


# from contextlib import nullcontext
from contextlib import asynccontextmanager
from typing import Optional
import time
from datetime import datetime, timedelta
import platform
import os
import requests
import json
import asyncio
import websockets
import logging
from logging.handlers import RotatingFileHandler
from google.auth import default
import traceback
from flask import Flask
import threading
import nest_asyncio
nest_asyncio.apply()

VER = "2025050615 Trial"

app = Flask(__name__)

# éœ€è¦ç­‰å¾…å›è¦†
reply_actions_to_check = {"user_get_num", "get_num_status"}
# reply_actions_to_check = {"get_num_status"}
actions_to_check = {"wait_time_avg", "new_get_num", "get_num_switch"}
# actions_to_check = {"wait_time_avg", "new_get_num", "get_num_switch", "user_get_num"}


def local_datetime():
    return f"{datetime.now().astimezone().strftime('%Y-%m-%d %H:%M:%S')}"


@app.route('/reboot', methods=['GET', 'POST'])
def my_exit():
    # global sys_reboot
    # global mainpi_main_crawler
    try:
        # å•Ÿå‹•å¾Œè‡ºåŸ·è¡Œç·’
        threadE = threading.Thread(target=exit_th)
        threadE.start()
        logging.info(f"Exit event return {local_datetime()}")
        print(f"\nExit event return {local_datetime()}", flush=True)
        return f"{local_datetime()} Exit!"
    except Exception as e:
        logging.error(f"Error exit: {e}")
        print(f"Error exit: {e}", flush=True)
        return f"Error exit: {e}", 500  # è¿”å› HTTP 500 éŒ¯èª¤


def exit_th():
    logging.warning(f'{local_datetime()} çµæŸç¨‹åº(ç¨‹å¼é‡æ–°å•Ÿå‹•)!!!')
    time.sleep(1)
    # stop_all_threads(60)   # 60 sec
    time.sleep(5)
    os._exit(0)


class LockWithNotification:
    def __init__(self):
        self._lock = asyncio.Lock()
        self._waiting_messages = {}

    @asynccontextmanager
    async def acquire(self, context: Optional[str] = None):
        """å¸¶æœ‰ç­‰å¾…é€šçŸ¥çš„é–å®šä¸Šä¸‹æ–‡ç®¡ç†å™¨"""
        start_wait = time.monotonic()
        acquired = False

        try:
            # å˜—è©¦éé˜»å¡ç²å–é–
            if not self._lock.locked():
                await self._lock.acquire()
                acquired = True
                yield
                # print(f"ğŸ”“ å…ç­‰å¾…é–å®š:{context} ", end='', flush=True)
                return

            # è¨˜éŒ„ç­‰å¾…é–‹å§‹
            if context:
                task_id = id(asyncio.current_task())
                self._waiting_messages[task_id] = context
                # print(f"âŒ› ç­‰å¾…é–å®š:{context} ", end='', flush=True)

            # ç­‰å¾…é–å®šä¸¦è¨˜éŒ„æ™‚é–“
            start_time = time.monotonic()
            while not acquired:
                try:
                    await asyncio.wait_for(
                        self._lock.acquire(),
                        # timeout=0.5  # æª¢æŸ¥é–“éš”
                        timeout=1.0  # æª¢æŸ¥é–“éš”, ä¸å¯å¤ªå°ï¼Œå¤ªå°ç³»çµ±æœƒå¡ä½
                    )
                    acquired = True
                except asyncio.TimeoutError:
                    wait_time = time.monotonic() - start_time
                    if context:
                        # print(f"â³ ä»åœ¨ç­‰å¾… [{context}] å·²ç­‰å¾… {wait_time:.1f}ç§’...", end='', flush=True)
                        pass

            # é–å®šç²å–æˆåŠŸ
            wait_duration = time.monotonic() - start_wait
            # if wait_duration > 0.01 and context:  # åªæœ‰å¯¦éš›ç­‰å¾…æ‰è¨˜éŒ„
            #     print(f"âœ… ç²å–é–å®š [{context}] ç­‰å¾…æ™‚é–“: {wait_duration:.3f}ç§’", end='', flush=True)
            # print(f"âœ… ç²å–é–å®š:[{context}],ç­‰å¾…æ™‚é–“:{wait_duration:.3f}ç§’ ", end='', flush=True)
            yield

        finally:
            if acquired:
                self._lock.release()
            if context:
                task_id = id(asyncio.current_task())
                self._waiting_messages.pop(task_id, None)

    def get_waiting_tasks(self) -> dict:
        """ç²å–ç•¶å‰ç­‰å¾…ä¸­çš„ä»»å‹™è³‡è¨Š"""
        return self._waiting_messages.copy()


class TracedLock:
    """è¿½è¹¤ç­‰å¾…æ™‚é–“çš„é–"""

    def __init__(self, name="unnamed_lock"):
        self._lock = asyncio.Lock()
        self.name = name

    async def __aenter__(self):
        task = asyncio.current_task()
        task_id = id(task)
        start_wait = time.time()

        # ç«‹å³æª¢æŸ¥é–ç‹€æ…‹
        if self._lock.locked():
            wait_start_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(
                f"ç­‰å¾… {self.name} é–... [é–‹å§‹æ™‚é–“: {wait_start_time}]", end='', flush=True)

            # å¯¦éš›ç²å–é–
            await self._lock.acquire()

            # è¨ˆç®—ç­‰å¾…æ™‚é–“ä¸¦é¡¯ç¤º
            wait_duration = time.time() - start_wait
            wait_end_time = datetime.now().strftime("%H:%M:%S.%f")[:-3]
            print(
                f"å–å¾— {self.name} é–ï¼Œç­‰å¾…äº† {wait_duration:.3f} ç§’ [çµæŸæ™‚é–“: {wait_end_time}]", end='', flush=True)
        else:
            # æ²’æœ‰ç­‰å¾…ï¼Œç›´æ¥ç²å–é–
            await self._lock.acquire()

        return self

    async def __aexit__(self, exc_type, exc_val, exc_tb):
        self._lock.release()


class Logger:
    @staticmethod
    def log(message):
        """é¡¯ç¤ºå¸¶æ™‚é–“æˆ³çš„ç‹€æ…‹è¨Šæ¯"""
        timestamp = datetime.now().strftime("%H:%M:%S.%f")[:-3]
        print(f"{timestamp} {message}", flush=True)


def setup_logger(log_to_console=True, log_to_file=True, log_level=logging.DEBUG, max_bytes=5*1000*1024, backup_count=1):
    # Get the current script file name without extension
    script_name = os.path.splitext(os.path.basename(__file__))[0]
    log_file = f"{script_name}.log"

    # Create a logger
    logger = logging.getLogger()
    logger.setLevel(log_level)

    # Clear any existing handlers
    if logger.hasHandlers():
        logger.handlers.clear()

    # Create handlers based on user preference
    if log_to_console:
        console_handler = logging.StreamHandler()
        console_handler.setLevel(log_level)
        logger.addHandler(console_handler)

    if log_to_file:
        file_handler = RotatingFileHandler(
            log_file, maxBytes=max_bytes, backupCount=backup_count)
        file_handler.setLevel(log_level)
        logger.addHandler(file_handler)

    # Create a formatter and set it for all handlers
    formatter = logging.Formatter(
        '%(asctime)s - %(name)s - %(levelname)s - %(message)s')
    for handler in logger.handlers:
        handler.setFormatter(formatter)


class ClientManager:
    def __init__(self):
        self.clients = {}
        # self.lock = asyncio.Lock()
        self.lock = TracedLock("ClM_lock")

    async def remove_client(self, caller_id):
        async with self.lock:
            if caller_id in self.clients:
                del self.clients[caller_id]

    async def add_connection(self, caller_id, websocket, ws_type):
        """æ·»åŠ ä¸€å€‹æ–°çš„WebSocketé€£æ¥åˆ°æŒ‡å®šcaller_id"""

        clients = await client_manager.get_all_clients()
        # print(f'add_connection clients:{clients}')
        # å–å¾— caller_id çš„ caller_numï¼Œå¦‚æœä¸å­˜åœ¨å‰‡é è¨­ 0ï¼Œä¸¦ç¢ºä¿æ˜¯ int
        existing_num = clients.get(caller_id, {}).get('caller_num', 0)
        caller_num = int(existing_num)  # ç¢ºä¿æ˜¯ int
        # print(f'add_connection caller_num:{caller_num}')

        async with self.lock:
            if caller_id not in self.clients:
                self.clients[caller_id] = {
                    # 'connections': set(),
                    'connections': {},    # åŸæœ¬æ˜¯ set()ï¼Œç¾åœ¨æ”¹æˆ dict
                    # 'caller_num': 0,
                    'caller_num': caller_num,
                    'caller_name': '',
                    'connect_time': datetime.now(),
                    'disconnect_time': None
                }
            
            # !!!@@@
            # self.clients[caller_id]['connections'].add(websocket)
            self.clients[caller_id]['connections'][websocket] = ws_type
            
            self.clients[caller_id]['disconnect_time'] = None
            
        # clients = await client_manager.get_all_clients()
        # print(f'add_connection_1 clients:{clients}')

    async def remove_connection(self, caller_id, websocket):
        """å¾æŒ‡å®šcaller_idç§»é™¤ä¸€å€‹WebSocketé€£æ¥"""
        async with self.lock:
            if caller_id in self.clients:
                print(f'discard(websocket):{caller_id}', end='\n', flush=True)
                
                #!!!@@@
                # self.clients[caller_id]['connections'].discard(websocket)
                del self.clients[caller_id]['connections'][websocket]

                # å¦‚æœæ²’æœ‰é€£æ¥äº†ï¼Œè¨˜éŒ„æ–·é–‹æ™‚é–“
                if not self.clients[caller_id]['connections']:
                    # print(f'è¨˜éŒ„æ–·é–‹æ™‚é–“:{caller_id}', end='\n',
                    #       flush=True)      # !!!@@@
                    self.clients[caller_id]['disconnect_time'] = datetime.now()

    async def update_caller_info(self, caller_id, caller_num=None, caller_name=None):
        """æ›´æ–°callerçš„è™Ÿç¢¼æˆ–åç¨±"""
        async with self.lock:
            if caller_id in self.clients:
                if caller_num is not None:
                    self.clients[caller_id]['caller_num'] = caller_num
                    # print(
                    #     f"update_caller_info set clients[{caller_id}][{caller_num}] = {caller_num}")

    async def notify_clients(self, caller_id, message, ws_type_enable):     # ws_type_enable 1:CMB Caller, 2:SOFT CMB Caller, 4:user_get_num
        """é€šçŸ¥æŒ‡å®šcaller_idçš„æ‰€æœ‰é€£æ¥"""
        # print(f'notify_clients:{caller_id},{message} ', end='', flush=True)
        async with self.lock:
            # print('na ', end='', flush=True)
            if caller_id in self.clients:
                # print('nb ', end='', flush=True)
                disconnected = set()
                # print(f'clients:{self.clients}')
                
                # !!!@@@
                # for websocket in self.clients[caller_id]['connections']:
                for websocket, ws_type in self.clients[caller_id]['connections'].items():
                    # print('nc ', end='', flush=True)
                    try:
                        if websocket.open:
                            if ws_type & ws_type_enable:
                                # print('nd ', end='', flush=True)
                                # EX: v0005,696,update
                                # logging.info(f"é€šçŸ¥å®¢æˆ¶ç«¯:{message}")
                                await websocket.send(message)
                                print(f'ä¸»å‹•é€šçŸ¥:{ws_type},{ws_type_enable}', flush=True)
                            else:
                                print(f'ä¸ä¸»å‹•é€šçŸ¥:{ws_type},{ws_type_enable}', flush=True)
                                pass
                        else:
                            # print('ne ', end='', flush=True)
                            logging.info("add(websocket)")
                            disconnected.add(websocket)
                    except Exception as e:
                        print('nf ', end='', flush=True)
                        logging.error(f"é€šçŸ¥å®¢æˆ¶ç«¯å¤±æ•—: {e}")
                        traceback.print_exc()
                        disconnected.add(websocket)

                # ç§»é™¤å·²æ–·é–‹çš„é€£æ¥
                for ws in disconnected:
                    print(f'ç§»é™¤å·²æ–·é–‹çš„é€£æ¥:{caller_id}', end='\n', flush=True)
                    
                    #!!!@@@
                    # self.clients[caller_id]['connections'].discard(ws)
                    del self.clients[caller_id]['connections'][websocket]


    async def get_caller_num(self, caller_id):
        """ç²å–æŒ‡å®šcaller_idçš„ç•¶å‰è™Ÿç¢¼"""
        async with self.lock:
            # print(
            #     f"get_caller_num:{caller_id},{self.clients[caller_id]['caller_num']}", end='\n', flush=True)
            if caller_id in self.clients:
                return self.clients[caller_id]['caller_num']
            return 0

    async def cleanup(self):
        """æ¸…ç†é•·æ™‚é–“ç„¡é€£æ¥çš„callerè¨˜éŒ„"""
        async with self.lock:
            now = datetime.now()
            to_remove = []
            for caller_id, info in self.clients.items():
                if info['disconnect_time'] and (now - info['disconnect_time']).total_seconds() > 3600:
                    to_remove.append(caller_id)
            for caller_id in to_remove:
                del self.clients[caller_id]

    async def get_all_clients(self):
        """ç²å–æ‰€æœ‰å®¢æˆ¶ç«¯è³‡è¨Š"""
        async with self.lock:
            return {k: v for k, v in sorted(self.clients.items())}


client_manager = ClientManager()


class JSONMemoryManager:
    def __init__(self):
        self.data = {"records": []}  # è¨˜æ†¶é«”ä¸­çš„è³‡æ–™çµæ§‹

    def add_data(self, new_record):
        """æŒçºŒæ·»åŠ æ–°è³‡æ–™"""
        # print(f'åŠ å…¥è³‡æ–™:{new_record}')
        # new_record_1 = json.dumps(new_record)
        new_record_1 = json.loads(new_record)
        self.data["records"].append(new_record_1)  # [1]

    def search_data(self, condition):
        """æ ¹æ“šæ¢ä»¶æœç´¢è³‡æ–™"""
        matched = [record for record in self.data["records"]
                   if condition(record)]  # [2][3]
        return matched

    def remove_matched(self, matched):
        """è‡ªå‹•æ•´ç†å‰©é¤˜è³‡æ–™"""
        self.data["records"] = [
            record for record in self.data["records"] if record not in matched]  # [4]


manager = JSONMemoryManager()

# é€£çµ CMB Main Server


class WebSocketClient:
    def __init__(self, ws_url):     # CMB Main Server
        """åˆå§‹åŒ– WebSocket Client"""
        print("åˆå§‹åŒ– WebSocket Client")
        self.ws_url = ws_url
        self.cmb_msg = ''
        self.ws = None  # CMB Main Server
        self.retry_delay = 5
        # self.send_lock = asyncio.Lock()
        self.send_lock = TracedLock("send_lock")

    async def connect(self):     # CMB Main Server
        while True:
            try:
                # async with websockets.connect(
                #     self.ws_url,
                #     ping_interval=15,  # å®¢æˆ¶ç«¯ä¹Ÿç™¼é€ ping
                #     ping_timeout=5,
                # ) as ws:

                async with websockets.connect(
                    self.ws_url,
                    ping_interval=30,  # å¾ 15 ç§’å¢åŠ åˆ° 30 ç§’
                    ping_timeout=10,   # å¾ 5 ç§’å¢åŠ åˆ° 10 ç§’
                ) as ws:

                    self.ws = ws
                    self.retry_delay = 5
                    logging.info(f"å·²é€£æ¥åˆ° CMB Main Server {self.ws_url}")

                    # print('å‚³é€ tawe', flush=True)
                    connect_data = {
                        "source": "tawe"
                    }
                    if self.ws:
                        await self.ws.send(json.dumps(connect_data))

                    await self.listen()
                    await asyncio.sleep(self.retry_delay)    # !!!@@@

            except websockets.exceptions.ConnectionClosed as e:
                logging.error(
                    f"CMB Main Server é€£æ¥é—œé–‰ï¼Œä»£ç¢¼: {e.code}, åŸå› : {e.reason}")
                await asyncio.sleep(self.retry_delay)
                self.retry_delay = min(self.retry_delay * 2, 60)

            except Exception as e:
                logging.error(f"CMB Main Server æœªçŸ¥éŒ¯èª¤: {e}")
                await asyncio.sleep(self.retry_delay)

    async def listen(self):  # CMB Main Server
        """è™•ç†æ¥æ”¶åˆ°çš„è¨Šæ¯"""
        try:
            async for message in self.ws:
                try:
                    if not is_json(message):
                        logging.warning(f"æ”¶åˆ°é JSON è¨Šæ¯ï¼Œç•¥é: {message}")
                        continue

                    self.cmb_msg = message  # å„²å­˜åŸå§‹è¨Šæ¯
                    manager.add_data(message)

                    # å„ªå…ˆæ‰¾å‡ºç¬¦åˆ action çš„è³‡æ–™
                    cmb_msg = manager.search_data(
                        lambda x: x.get("action") in actions_to_check)

                    # è‹¥æ‰¾ä¸åˆ°ç¬¦åˆ action çš„è³‡æ–™ï¼Œå˜—è©¦æ‰¾ wait_time_avg, send å›è¦†
                    if not cmb_msg and not manager.search_data(lambda x: "action" in x):
                        cmb_msg = manager.search_data(
                            lambda x: "wait_time_avg" in x)
                        if not cmb_msg:
                            logging.warning("æ‰¾ä¸åˆ° wait_time_avg è³‡æ–™ï¼Œç•¥éè™•ç†")
                            continue
                        if cmb_msg[0].get('wait_time_avg') == '':   # ä¾‹è¡Œè³‡æ–™
                            # logging.info("æ”¶åˆ°ç©ºçš„ wait_time_avgï¼Œç•¥éè™•ç†")
                            continue

                    if cmb_msg:
                        manager.remove_matched(cmb_msg)
                        caller_id = cmb_msg[0].get('caller_id', '')

                        if not caller_id:
                            logging.error(f"å›è¦†è³‡æ–™éŒ¯èª¤ï¼Œç¼ºå°‘ caller_id: {cmb_msg}")
                            continue

                        logging.info(f"ç¾¤ç™¼è¨Šæ¯è‡³ caller_id={caller_id}: {cmb_msg}")
                        await client_manager.notify_clients(caller_id, f'{cmb_msg}', 0xff)

                except Exception as inner_e:
                    logging.error(
                        f"è™•ç†å–®ä¸€è¨Šæ¯æ™‚ç™¼ç”ŸéŒ¯èª¤: {inner_e}\nè¨Šæ¯å…§å®¹: {message}", exc_info=True)

        except websockets.exceptions.ConnectionClosedError as e:
            logging.error(f"CMB Main Server é€£æ¥ä¸­æ–·: {e}")
            await asyncio.sleep(2)
            raise e

        except Exception as e:
            logging.error(f"CMB Main Server ç™¼ç”Ÿæœªé æœŸéŒ¯èª¤: {e}", exc_info=True)
            await asyncio.sleep(2)
            raise e

    async def send(self, message):      # CMB Main Server
        """ç™¼é€è¨Šæ¯"""
        async with self.send_lock:
            # Logger.log(f"ç™¼é€è¨Šæ¯è‡³ CMB {message}")
            if self.ws:
                await self.ws.send(message)
            # await asyncio.sleep(0.01)       # ä¸é€£çºŒç™¼é€!!!@@@

    async def close(self):     # CMB Main Server
        """é—œé–‰ WebSocket é€£æ¥"""
        if self.ws:
            await self.ws.close()
            self.ws = None


def is_json(my_string):
    try:
        json.loads(my_string)
        return True
    except ValueError:
        return False

# cmb-caller-frontend WebSocket Server, é€£çµ Caller


def has_websocket(clients, target_websocket):
    for client_data in clients.values():
        if target_websocket in client_data['connections']:
            return True
    return False


class WebSocketServer:
    def __init__(self, host, port):       # Caller
        """åˆå§‹åŒ– WebSocket Server"""
        self.host = host
        self.port = port
        self.vendor_id = "tawe"
        self.ws_client = None   # é€£çµ CMB Main Server
        self.server = None      # é€£çµ Caller
        self.last_num = 0
        self.ws_cmd_lock = LockWithNotification()

    async def start(self):       # Caller
        """å•Ÿå‹•Server"""
        self.server = await websockets.serve(
            self.handler,
            self.host,
            self.port,
            ping_interval=30,      # xx ç§’ï¼Œæ¸›å°‘è³‡æºæ¶ˆè€—
            ping_timeout=10,       # xx ç§’ï¼Œçµ¦äºˆå¯¬è£•çš„å›æ‡‰æ™‚é–“
            max_size=4096,        # é™åˆ¶è¨Šæ¯å¤§å°ï¼Œé¿å…è¨˜æ†¶é«”å•é¡Œ
            compression=None       # ESP32 ä¸éœ€è¦å£“ç¸®ï¼Œå¯æé«˜æ•ˆèƒ½
        )
        logging.info(
            f"cmb-caller-frontend WebSocket Server å·²å•Ÿå‹•: ws://{self.host}:{self.port}")
        await self.server.wait_closed()  # ä¿æŒServeré‹è¡Œ

    async def stop(self):       # Caller
        """åœæ­¢Server"""
        if self.server:
            self.server.close()
            await self.server.wait_closed()

    async def handler(self, websocket, path):       # Caller
        """è™•ç†æ–°Clienté€£æ¥"""
        new_connect = True
        executed_remove = False
        response_auth = False

        # print("è™•ç†æ–°Clienté€£æ¥")
        caller_id = None
        try:
            # await asyncio.sleep(1)  # !!!@@@
            async for message in websocket:  # è¿´åœˆ
                # print("è™•ç†æ–°Clienté€£æ¥_1")

                # print("æ”¶åˆ°è¨Šæ¯:", message)
                # æª¢æŸ¥è¨Šæ¯æ˜¯å¦ç‚º JSON æ ¼å¼
                try:
                    json_data = json.loads(message)
                    # print("æ”¶åˆ°æœ‰æ•ˆçš„ JSON è¨Šæ¯:", json_data)

                    caller_id = json_data.get('caller_id')

                    # # æª¢æŸ¥æ˜¯å¦å·²é©—è­‰
                    # clients = await client_manager.get_all_clients()
                    # # if caller_id not in clients:
                    # if not has_websocket(clients, websocket):
                    #     # if caller_id.startswith('a0') or caller_id.startswith('z'):
                    #     if json_data.get('action') == 'user_get_num':
                    #         print(f"*** ä»£åŠ å…¥æˆæ¬Š! {json_data} ***")
                    #         message_x = f'{caller_id},AUTH,liM3yMfrMIAWHmFVvGQ1RA3BmdCTx2/hHdFbzv7ulcQ='
                    #         response_auth = await self.handle_auth(caller_id, message_x.split(','), websocket)
                    #     else:
                    #         logging.info(f"æœªæˆæ¬Šæ“ä½œ:{json_data}")
                    #         await websocket.send("Fail,003,æœªæˆæ¬Šæ“ä½œ")  # !!!@@@
                    #         continue
                    # else:
                    #     pass
                    #     print(f"*** å·²åŠ å…¥æˆæ¬Š! {json_data} ***")

                    # æª¢æŸ¥æ˜¯å¦å·²é©—è­‰
                    clients = await client_manager.get_all_clients()
                    if not has_websocket(clients, websocket):
                        logging.info(f"æœªæˆæ¬Šæ“ä½œ:{json_data}")
                        await websocket.send("Fail,003,æœªæˆæ¬Šæ“ä½œ")  # !!!@@@
                        continue

                    if json_data.get('action') in reply_actions_to_check:
                        await self.handle_json_cmd(caller_id, json_data, websocket)
                    else:
                        await self.handle_json_cmd_no_reply(caller_id, json_data, websocket)
                    continue
                except json.JSONDecodeError:
                    # print("æ”¶åˆ°é JSON è¨Šæ¯:", message)
                    pass

                # è§£æè¨Šæ¯
                caller_id, m_cmd, m_info = self.parse_message(message)

                if new_connect:
                    new_connect = False
                    # print(f'æ–°Clienté€£æ¥:{caller_id},{m_cmd},{m_info}')
                    print(f'æ–°Clienté€£æ¥:{caller_id},{m_cmd} ',
                          end='', flush=True)

                # if m_cmd == 'ping':
                #     await websocket.send('pong')
                #     continue

                # å°å‡ºè³‡è¨Š
                if m_cmd == 'send' or m_cmd == 'auth' or m_cmd == 'get_num_info' or m_cmd == 'info':
                    if m_info != '' and m_cmd != 'auth':
                        print(f' æ”¶:{caller_id},{m_cmd},{m_info} ',
                              end='', flush=True)
                    else:
                        print(f' æ”¶:{caller_id},{m_cmd} ', end='', flush=True)

                # è™•ç†é©—è­‰
                if m_cmd == 'auth':
                    # new_connect = False
                    # await self.handle_auth(caller_id, message.split(','), websocket)
                    response_auth = await self.handle_auth(caller_id, message.split(','), websocket)
                    continue

                # æª¢æŸ¥æ˜¯å¦å·²é©—è­‰
                clients = await client_manager.get_all_clients()
                if caller_id not in clients:
                    # if caller_id.startswith('a0') or caller_id.startswith('z'):
                    if caller_id.startswith('z'):
                        print(f"*** ä»£åŠ å…¥æˆæ¬Š! {caller_id},{m_cmd},{m_info} ***")
                        message_x = f'{caller_id},AUTH,liM3yMfrMIAWHmFVvGQ1RA3BmdCTx2/hHdFbzv7ulcQ='
                        response_auth = await self.handle_auth(caller_id, message_x.split(','), websocket)
                    else:
                        logging.info(f"æœªæˆæ¬Šæ“ä½œ:{caller_id},{m_cmd},{m_info}")
                        await websocket.send("Fail,003,æœªæˆæ¬Šæ“ä½œ")
                        continue

                if not response_auth:
                    # if caller_id.startswith('a0') or caller_id.startswith('z'):
                    if caller_id.startswith('z'):
                        print(f"*** ä»£åŠ å…¥æˆæ¬Š!! {caller_id},{m_cmd},{m_info} ***")
                        message_x = f'{caller_id},AUTH,liM3yMfrMIAWHmFVvGQ1RA3BmdCTx2/hHdFbzv7ulcQ='
                        response_auth = await self.handle_auth(caller_id, message_x.split(','), websocket)
                    else:
                        logging.info(f"æœªæˆæ¬Šæ“ä½œ:{caller_id},{m_cmd},{m_info}")
                        await websocket.send("Fail,003,æœªæˆæ¬Šæ“ä½œ.")
                        continue

                # è™•ç†å…¶å®ƒæŒ‡ä»¤

                # if new_connect:
                #     new_connect = False
                #     # ä¸æ‡‰å¹«åŠ å…¥ï¼Œé ˆç”± auth åŠ å…¥
                #     print(f"åŠ å…¥æ–°websocket! {caller_id},{m_cmd},{m_info}")
                #     await client_manager.add_connection(caller_id, websocket)

                # å–å¾— 'å–è™Ÿè³‡è¨Š'
                if m_cmd == 'get_num_info':
                    await self.handle_get_num_info(caller_id, message.split(','), websocket)
                    continue

                if m_cmd == 'ping':
                    # print(f'ping:{caller_id},{m_cmd},{m_info}')
                    await websocket.send('pong')
                    existing_num = clients.get(
                        caller_id, {}).get('caller_num', 0)
                    current_num = int(existing_num)  # ç¢ºä¿æ˜¯ int
                    # if (current_num == 0 and int(m_info) != 0):
                    if current_num == 0 and m_info.isdigit() and int(m_info) != 0:
                        # print(f'set caller_num: {caller_id}:{int(m_info)}')
                        clients[f'{caller_id}']['caller_num'] = int(m_info)
                    continue

                if m_cmd == 'info':
                    await websocket.send(f'OK,{caller_id},info')
                    continue

                if m_cmd == 'get':
                    # ç²å–ç•¶å‰è™Ÿç¢¼
                    current_num = await client_manager.get_caller_num(caller_id)
                    # print(f'get current_num:{current_num}')
                    await websocket.send(f'OK,{caller_id},{current_num},get')
                    continue

                if m_cmd == 'send' or (m_cmd == '' and m_info != '0'):
                    # æ›´æ–°è™Ÿç¢¼ä¸¦é€šçŸ¥æ‰€æœ‰å®¢æˆ¶ç«¯

                    # if m_info != '':
                    #     print(f'send? æ”¶:{caller_id},{m_cmd},{m_info} ',
                    #           end='', flush=True)
                    # else:
                    #     print(f'send? æ”¶:{caller_id},{m_cmd} ',
                    #           end='', flush=True)

                    new_num = int(m_info)
                    # print('send: ', end='', flush=True)
                    await client_manager.update_caller_info(caller_id, new_num)
                    # print(f" ç™¼:OK,{caller_id},{new_num},send ",
                    #       end='', flush=True)
                    await websocket.send(f'OK,{caller_id},{new_num},send')

                    await client_manager.notify_clients(caller_id, f'OK,{caller_id},{new_num},update',0xff)

                    # é€šçŸ¥CMBä¸»ä¼ºæœå™¨
                    await self.handle_message(caller_id, new_num)
                    continue

                print(f"éŒ¯èª¤çš„å‘½ä»¤! {caller_id},{m_cmd},{m_info}")
                await websocket.send(f'OK,{caller_id},{self.last_num},{m_cmd}')

        except websockets.exceptions.ConnectionClosed as e:
            if caller_id:
                await client_manager.remove_connection(caller_id, websocket)
                executed_remove = True
                logging.error(
                    f"å®¢æˆ¶ç«¯ {caller_id} æ–·é–‹ï¼Œä»£ç¢¼: {e.code}, åŸå› : {e.reason}")
        except Exception as e:
            logging.error(f"è™•ç†å®¢æˆ¶ç«¯è¨Šæ¯æ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
            traceback.print_exc()
            if caller_id:
                await client_manager.remove_connection(caller_id, websocket)
                executed_remove = True
        finally:
            # print("finally: remove_connection!!!")
            # if caller_id:
            if caller_id and not executed_remove:
                # ç¢ºä¿æ¸…ç†
                # print(f"finally:{caller_id},{clients[caller_id]['connections']}") # KeyError: 'v0005'
                await client_manager.remove_connection(caller_id, websocket)
            # print(f"finally: PASS remove_connection!!!")

    # Caller
    async def handle_json_cmd_no_reply(self, caller_id, json_data, websocket):
        async with self.ws_cmd_lock.acquire(f'ws_cmd_lock json_cmd:{caller_id}'):
            print(f"handle_json_cmd_no_reply {json_data}!!!")
            # action_value = json_data.get('action')
            max_retries = 3
            retry_delay = 3
            for attempt in range(max_retries):
                if self.ws_client:
                    try:
                        await self.ws_client.send(json.dumps(json_data))
                        return

                    except Exception as e:
                        logging.error(
                            f"ä¸Šå±¤é©—è­‰å¤±æ•— (å˜—è©¦ {attempt+1}/{max_retries}): {e}")
                        traceback.print_exc()
                        if attempt < max_retries - 1:
                            await asyncio.sleep(retry_delay)
                        continue
            await websocket.send("Fail,001,ä¸æ”¯æ´æ­¤åŠŸèƒ½,auth")

    async def handle_json_cmd(self, caller_id, json_data, websocket):       # Caller
        async with self.ws_cmd_lock.acquire(f'ws_cmd_lock json_cmd:{caller_id}'):
            print(f"handle_json_cmd {json_data}!!!")
            # action_value = json_data.get('action')
            pass
            max_retries = 3
            retry_delay = 3
            for attempt in range(max_retries):
                if self.ws_client:
                    try:
                        await self.ws_client.send(json.dumps(json_data))
                        # ç­‰å¾…å›æ‡‰
                        # print('handle_json_cmd ç­‰å¾…å›æ‡‰')
                        start_time = time.time()

                        cmb_msg = []
                        while not cmb_msg and time.time() - start_time < 20:
                            # cmb_msg = manager.search_data(
                            #     lambda x: x.get("action") == "get_num_info")
                            # ä½¿ç”¨ lambda å‡½æ•¸ä¾†æª¢æŸ¥ä¸¦æ”¾å…¥ cmb_msg
                            cmb_msg = manager.search_data(
                                lambda x: x.get("action") in reply_actions_to_check)
                            if cmb_msg:
                                # print(f'æ‰¾åˆ°è³‡æ–™{action_value}:{cmb_msg}')
                                break
                            else:
                                # print(f"num_info:{caller_id} å°šæœªæ‰¾åˆ°è³‡æ–™ {action_value}ï¼Œç¹¼çºŒç­‰å¾…...")
                                pass
                            await asyncio.sleep(0.001)
                            # await asyncio.sleep(2)

                        # print(
                        #     f'handle_json_cmd {action_value} æ‰¾åˆ° json å›è¦†è³‡æ–™:{cmb_msg}')

                        if cmb_msg:
                            manager.remove_matched(cmb_msg)     # ç§»é™¤å·²åŒ¹é…è³‡æ–™
                            await websocket.send(f"{cmb_msg}")
                            if cmb_msg[0].get('action') == 'user_get_num':
                                print(f'éœ€ç™¼é€è‡³åº—ä¸»çš„è£ç½®:{cmb_msg} ', flush=True)
                                logging.info(
                                    f"ç¾¤ç™¼è¨Šæ¯è‡³ caller_id={caller_id}: {cmb_msg}")
                                await client_manager.notify_clients(caller_id, f'{cmb_msg}',0x2)
                            return
                        else:
                            print(
                                f'handle_json_cmd é€¾æ™‚é‡é€! (å˜—è©¦ {attempt+1}/{max_retries})')

                    except Exception as e:
                        logging.error(
                            f"ä¸Šå±¤é©—è­‰å¤±æ•— (å˜—è©¦ {attempt+1}/{max_retries}): {e}")
                        traceback.print_exc()
                        if attempt < max_retries - 1:
                            await asyncio.sleep(retry_delay)
                        continue
            await websocket.send("Fail,001,ä¸æ”¯æ´æ­¤åŠŸèƒ½,auth")

    async def handle_get_num_info(self, caller_id, parts, websocket):       # Caller
        # async with self.ws_cmd_lock:  # ä½¿ç”¨é–ä¾†ç¢ºä¿ä¸€æ¬¡åªæœ‰ä¸€å€‹é©—è­‰éç¨‹
        async with self.ws_cmd_lock.acquire(f'ws_cmd_lock get_num:{caller_id}'):
            if len(parts) != 2:
                logging.info("ç„¡æ•ˆçš„ get_num_info æ ¼å¼!")
                await websocket.send("Fail,006,ç„¡æ•ˆçš„CMDæŒ‡ä»¤")
                return

            max_retries = 3
            retry_delay = 3

            for attempt in range(max_retries):
                login_data = {
                    "action": "get_num_info",         # å‹•ä½œæŒ‡ä»¤
                    "vendor_id": self.vendor_id,      # å«è™Ÿæ©Ÿå» å•† id
                    "caller_id": caller_id,          # å«è™Ÿæ©Ÿ id
                    "uuid": "8c4530b1-8747-4b19-8da7-3f853f8712f3"  # å°åŒ…è­˜åˆ¥ç¢¼
                }

                if self.ws_client:
                    try:
                        # print(f'ws_client.send: {json.dumps(login_data)}')
                        # await self.ws_client.send(login_data)
                        # ç­‰å¾…å›æ‡‰
                        start_time = time.time()
                        self.ws_client.cmb_msg = ''
                        # while not self.ws_client.cmb_msg and time.time() - start_time < 10:
                        #     await asyncio.sleep(0.1)

                        cmb_msg = []
                        while not cmb_msg and time.time() - start_time < 60:
                            cmb_msg = manager.search_data(
                                lambda x: x.get("action") == "get_num_info")
                            if cmb_msg:
                                # print(f'æ‰¾åˆ°è³‡æ–™:{found_data}')
                                break
                            else:
                                # print(f"num_info:{caller_id} å°šæœªæ‰¾åˆ°è³‡æ–™ï¼Œç¹¼çºŒç­‰å¾…...")
                                pass
                            await asyncio.sleep(0.001)

                        # print(f'æ‰¾åˆ°è³‡æ–™:{cmb_msg}')
                        manager.remove_matched(cmb_msg)     # ç§»é™¤å·²åŒ¹é…è³‡æ–™

                        if cmb_msg:
                            # response = json.loads(cmb_msg)
                            response = dict(cmb_msg[0])
                        # if self.ws_client.cmb_msg:
                        #     response = json.loads(self.ws_client.cmb_msg)
                            if response.get("result") == "OK":
                                wait_num = response.get('wait_num', '')
                                curr_get_num = int(
                                    response.get('curr_num', '0'))
                                if (wait_num == ''):
                                    current_num = int(await client_manager.get_caller_num(caller_id))
                                    if (current_num < curr_get_num):
                                        wait_num = curr_get_num-current_num
                                    else:
                                        wait_num = curr_get_num

                                wait_num = int(wait_num)
                                # print(
                                #     f"handle_get_num_info:OK,{caller_id},{curr_get_num},{wait_num},get_num_info")
                                await websocket.send(f"OK,{caller_id},{curr_get_num},{wait_num},get_num_info")
                                # self.ws_client.cmb_msg = ''
                                return
                            else:
                                # è™•ç†éŒ¯èª¤å›æ‡‰
                                code = response.get("result").split(
                                    ',')[1].split(':')[0].strip()
                                msg_map = {
                                    '003': '007,ä¸æ”¯æ´æ­¤åŠŸèƒ½',
                                    '002': '002,ç„¡æ•ˆçš„CallerID',
                                    '001': '006,ç„¡æ•ˆçš„CMDæŒ‡ä»¤',
                                    '009': '007,æ–‡å­—éŒ¯èª¤/å…¶å®ƒ'
                                }
                                msg = msg_map.get(code, '001,é©—è­‰å¤±æ•—')
                                await websocket.send(f"Fail,{msg},auth")
                                return
                        else:
                            print(
                                f'handle_get_num_info é€¾æ™‚é‡é€! (å˜—è©¦ {attempt+1}/{max_retries})')

                    except Exception as e:
                        logging.error(
                            f"ä¸Šå±¤é©—è­‰å¤±æ•— (å˜—è©¦ {attempt+1}/{max_retries}): {e}")
                        traceback.print_exc()
                        if attempt < max_retries - 1:
                            await asyncio.sleep(retry_delay)
                        continue
            await websocket.send("Fail,001,ä¸æ”¯æ´æ­¤åŠŸèƒ½,auth")

    async def handle_auth(self, caller_id, parts, websocket):       # Caller
        """è™•ç†é©—è­‰è«‹æ±‚"""
        # print(f'handle_auth:{parts} ', end='', flush=True)
        # async with self.ws_cmd_lock:  # ä½¿ç”¨é–ä¾†ç¢ºä¿ä¸€æ¬¡åªæœ‰ä¸€å€‹é©—è­‰éç¨‹
        async with self.ws_cmd_lock.acquire(f'ws_cmd_lock auth:{caller_id}'):

            # print(f'{caller_id},è™•ç†é©—è­‰è«‹æ±‚')
            if len(parts) != 3:
                logging.info("ç„¡æ•ˆçš„é©—è­‰æ ¼å¼!")
                await websocket.send("Fail,004,ç„¡æ•ˆçš„é©—è­‰æ ¼å¼")
                return False

            encrypted_password = parts[2]
            max_retries = 3
            retry_delay = 3

            for attempt in range(max_retries):
                login_data = {
                    "action": "login",
                    "vendor_id": self.vendor_id,
                    "caller_id": caller_id,
                    "password": encrypted_password
                }

                if self.ws_client:
                    try:
                        start_time = time.time()
                        ws_type=-1
                        # ASTRO_cmb-caller
                        if (encrypted_password == 'liM3yMfrMIAWHmFVvGQ1RA3BmdCTx2/hHdFbzv7ulcQ='):
                            print(
                                f' *** CMB Caller:{caller_id} *** ', end='', flush=True)
                            clients = await client_manager.get_all_clients()
                            # print(f'get clients:{clients}')
                            existing_num = clients.get(
                                caller_id, {}).get('caller_num', 0)
                            current_num = int(existing_num)  # ç¢ºä¿æ˜¯ int
                            # cmb_msg = f'{{"action":"login","result":"OK","caller_name":"{caller_id} caller","curr_num":{current_num}}}'
                            cmb_msg = f'{{"action":"login","vendor_id":"tawe","caller_id":"{caller_id}","uuid":"","caller_name":"{caller_id}_caller","curr_num":"{current_num}","result":"OK"}}'
                            manager.add_data(cmb_msg)
                            ws_type = 1
                            # print(f'handle_auth cmb_msg:{cmb_msg}')
                            
                        else:
                            print(
                                f' *** SOFT CMB Caller:{caller_id} *** ', end='', flush=True)
                            await self.ws_client.send(json.dumps(login_data))
                            if encrypted_password=='user_get_num':
                                ws_type=4
                            else:
                                ws_type=2

                        # ç­‰å¾…å›æ‡‰
                        cmb_msg = []
                        while not cmb_msg and time.time() - start_time < 60:
                            cmb_msg = manager.search_data(
                                lambda x: x.get("action") == "login")
                            if cmb_msg:
                                # print(f'æ‰¾åˆ°è³‡æ–™:{found_data}')
                                break
                            else:
                                # print("AUTH:{caller_id} å°šæœªæ‰¾åˆ°è³‡æ–™ï¼Œç¹¼çºŒç­‰å¾…...")
                                pass
                            await asyncio.sleep(0.0001)

                        # print(f'æ‰¾åˆ°è³‡æ–™:{cmb_msg}')
                        manager.remove_matched(cmb_msg)     # ç§»é™¤å·²åŒ¹é…è³‡æ–™

                        if cmb_msg:
                            # response = json.loads(cmb_msg)
                            response = dict(cmb_msg[0])
                            if response.get("result") == "OK":
                                # é©—è­‰æˆåŠŸ
                                await client_manager.add_connection(caller_id, websocket,ws_type)
                                # print('auth: ', end='', flush=True)
                                await client_manager.update_caller_info(
                                    caller_id,
                                    caller_num=await client_manager.get_caller_num(caller_id),
                                    caller_name=response.get('caller_name', '')
                                )
                                # print(f'{caller_id},é©—è­‰æˆåŠŸ', end='\n', flush=True)
                                print(f'{caller_id},é©—è­‰æˆåŠŸ ', end='', flush=True)
                                await websocket.send(f"OK,{response.get('caller_name','')},auth")
                                self.ws_client.cmb_msg = ''
                                return True
                            else:
                                # è™•ç†éŒ¯èª¤å›æ‡‰
                                code = response.get("result").split(
                                    ',')[1].split(':')[0].strip()
                                msg_map = {
                                    '003': '001,é©—è­‰å¤±æ•—',
                                    '002': '002,ç„¡æ•ˆçš„CallerID',
                                    '001': '006,ç„¡æ•ˆçš„CMDæŒ‡ä»¤',
                                    '009': '007,æ–‡å­—éŒ¯èª¤/å…¶å®ƒ'
                                }
                                msg = msg_map.get(code, '001,é©—è­‰å¤±æ•—')
                                print(f'{caller_id},{msg}')
                                await websocket.send(f"Fail,{msg},auth")
                                return False
                        else:
                            print(
                                f'handle_auth é€¾æ™‚é‡é€! (å˜—è©¦ {attempt+1}/{max_retries})')

                    except Exception as e:
                        logging.error(
                            f"ä¸Šå±¤é©—è­‰å¤±æ•— (å˜—è©¦ {attempt+1}/{max_retries}): {e}")
                        traceback.print_exc()
                        print(
                            f'self.ws_client.cmb_msg:{self.ws_client.cmb_msg}')
                        if attempt < max_retries - 1:
                            await asyncio.sleep(retry_delay)
                        continue
            await websocket.send("Fail,001,é©—è­‰å¤±æ•—,auth")
            return False

    async def force_close_connection(self, websocket, caller_id, reason):       # Caller
        """å¼·åˆ¶é—œé–‰é€£ç·šä¸¦æ¸…ç†è³‡æº"""
        Logger.log("å¼·åˆ¶é—œé–‰é€£ç·šä¸¦æ¸…ç†è³‡æº")
        try:
            # ç›´æ¥é—œé–‰ websocket
            # ç¢ºä¿é€£ç·šé—œé–‰
            if not websocket.closed:
                await websocket.close(code=1008, reason=reason)
            # å¾å®¢æˆ¶ç«¯ç®¡ç†å™¨ç§»é™¤
            if caller_id in await client_manager.get_all_clients():
                await client_manager.remove_client(caller_id)
            logging.warning(f"å·²å¼·åˆ¶é—œé–‰ {caller_id} é€£ç·šï¼ŒåŸå› : {reason}")
        except Exception as e:
            logging.error(f"å¼·åˆ¶é—œé–‰é€£ç·šæ™‚ç™¼ç”ŸéŒ¯èª¤: {e}")
            traceback.print_exc()

    def parse_message(self, message):       # m_cmd ä¸€å¾‹è®Šç‚ºå°å¯«
        """è§£ææ¥æ”¶åˆ°çš„è¨Šæ¯"""
        message = message.lower()
        info = ""
        m_cmd = ""
        try:
            parts = message.split(',')
            if len(parts) < 2:
                raise ValueError(
                    "è¨Šæ¯æ ¼å¼ç„¡æ•ˆï¼Œé æœŸæ ¼å¼ç‚º 'caller_id,m_info' æˆ– 'caller_id,m_cmd,m_info'")
            if len(parts) == 2:
                m_info = ''
                if parts[1] == 'get':
                    caller_id, m_cmd = parts
                elif parts[1] == 'ping':
                    caller_id, m_cmd = parts
                elif parts[1] == 'get_num_info':
                    caller_id, m_cmd = parts
                else:       # send
                    caller_id, m_info = parts
                    m_cmd = 'send'

            if len(parts) == 3:
                if parts[1] == 'ping' or parts[1] == 'send' or parts[1] == 'auth' or parts[1] == 'info':
                    caller_id, m_cmd, m_info = parts
                else:       # z0001,121,INFO:.....
                    caller_id, m_info, info = parts
                    m_cmd = 'send'
            # logging.info(f"parse_message return {caller_id}, {m_cmd.lower()}, {m_info}")
            return caller_id, m_cmd.lower(), m_info
        except Exception as e:
            logging.error(f"parse_message è™•ç†å¤±æ•— {e}")
            traceback.print_exc()

    async def handle_message(self, caller_id, call_num):    # 'send' ä½¿ç”¨       # Caller
        """è™•ç†è¨Šæ¯ä¸¦ç”Ÿæˆå›æ‡‰"""
        call_num = int(call_num)
        while True:
            try:
                data = {
                    "vendor_id": self.vendor_id,
                    "caller_id": caller_id,
                    "call_num": call_num,
                    "change": True,
                    "last_update": 0,
                    "uuid": "8c4530b1-8747-4b19-8da7-3f853f8712f3"
                }

                # json_data = json.dumps(data, indent=2)

                if self.ws_client:
                    # Logger.log(f"\nç™¼é€è¨Šæ¯è‡³ CMB: {json_data}")
                    # Logger.log(f"ç™¼é€è¨Šæ¯è‡³ CMB: {caller_id}, {call_num}")
                    # await self.ws_client.send(json_data)    # è‡³ CMB Main Server
                    await self.ws_client.send(json.dumps(data))

                    # ç­‰å¾…å›æ‡‰ï¼Œè¨­å®šè¶…æ™‚
                    start_time = time.time()
                    while not self.ws_client.cmb_msg and time.time() - start_time < 5:      # !!!@@@ 2 -> 5
                        await asyncio.sleep(0.1)

                    # print(f"(CMB) {self.ws_client.cmb_msg}")
                    response = f"{self.ws_client.cmb_msg}"
                    self.ws_client.cmb_msg = ''
                    return response

                return None
            except Exception as e:
                logging.error(
                    f"handle_message è™•ç†å¤±æ•— (éŒ¯èª¤: {e}), {caller_id}, {call_num}")
                # print('å¤±æ•—å¾Œç­‰å¾…10ç§’å†é‡è©¦!!!')
                print("handle_message 10ç§’å¾Œç¹¼çºŒç™¼é€è³‡æ–™!!!", flush=True)
                # traceback.print_exc()
                await asyncio.sleep(10)  # å¤±æ•—å¾Œç­‰å¾…10ç§’å†é‡è©¦
                print(f"handle_message ç¹¼çºŒç™¼é€è³‡æ–™!!! '{data}'", flush=True)


async def periodic_send_frame(ws_server):
    """å®šæœŸç™¼é€ç‹€æ…‹å’Œæ¸…ç†ç„¡æ•ˆé€£æ¥"""
    await asyncio.sleep(30)
    while True:
        start_time = datetime.now()

        # æ¸…ç†ç„¡æ•ˆé€£æ¥
        await client_manager.cleanup()

        # ç™¼é€ç‹€æ…‹æ›´æ–°
        clients = await client_manager.get_all_clients()
        active_client = 0
        connected_client = 0
        print("", flush=True)
        Logger.log("ç™¼é€ä¾‹è¡Œè³‡æ–™:")
        for caller_id, info in clients.items():
            try:
                is_connected = bool(info['connections'])
                is_active = info['disconnect_time'] is None or (
                    datetime.now() - info['disconnect_time']).total_seconds() < 600     # æœ‰æ•ˆé€£ç·š(æ–·ç·š10åˆ†é˜å…§)
                # datetime.now() - info['disconnect_time']).total_seconds() < 3600

                if is_connected:
                    connected_client += 1
                if is_active:
                    active_client += 1

                    # ç™¼é€æ›´æ–°åˆ°CMBä¸»ä¼ºæœå™¨
                    data = {
                        "vendor_id": "tawe",
                        "caller_id": caller_id,
                        "call_num": info['caller_num'],
                        "change": not is_connected,
                        "last_update": 0 if is_connected else (int((datetime.now() - info['disconnect_time']).total_seconds() / 60)+1),
                        "uuid": "8c4530b1-8747-4b19-8da7-3f853f8712f3"
                    }

                    if info['caller_num'] == '0':
                        print(
                            f"{caller_id}è³‡æ–™ç„¡æ•ˆ(info['caller_num']) ", end='', flush=True)
                    else:
                        print(
                            f'{data["caller_id"]},{data["call_num"]},{data["change"]},{data["last_update"]} ', end='', flush=True)
                    await ws_server.ws_client.send(json.dumps(data))

            except Exception as e:
                logging.error(f"ç™¼é€ä¾‹è¡Œè³‡æ–™æ™‚å‡ºéŒ¯(CMB Server (cloud run å®šæ™‚æ–·ç·š!)): {e}")
                print("10ç§’å¾Œç¹¼çºŒç™¼é€ä¾‹è¡Œè³‡æ–™!!!", flush=True)
                # traceback.print_exc()
                start_time = datetime.now() - timedelta(seconds=(60-10)
                                                        )     # å‡ºéŒ¯å¾Œå°‡ start_time è¨­ç‚ºxxç§’å‰
                break   # é›¢é–‹ for è¿´åœˆ

        print("", flush=True)
        # è¨˜éŒ„ç‹€æ…‹
        # print(f'è¨˜éŒ„ç‹€æ…‹ clients:{clients}')
        total_websockets = sum(len(client['connections'])
                               for client in clients.values())
        Logger.log(
            f"ç¸½å…±æœ‰ {len(clients)} å€‹ç´€éŒ„ä¸­ ID, "
            f"{active_client} å€‹æœ‰æ•ˆçš„ ID, "
            f"{connected_client} å€‹é€£ç·šä¸­ ID, "
            f"{total_websockets} å€‹é€£ç·šä¸­ Client"
        )

        # ç¢ºä¿æ¯60ç§’åŸ·è¡Œä¸€æ¬¡
        execution_time = (datetime.now() - start_time).total_seconds()
        await asyncio.sleep(max(60 - execution_time, 0))


def get_platform_config():
    """åˆ¤æ–· platform ä¸¦è¿”å›ç›¸æ‡‰é…ç½®"""
    os_name = platform.system()
    PORT = 8765
    if os_name == 'Windows':
        PORT = 38000
        # return PORT, "ws://localhost:8088", 'Windows'      # Local WIndows PC
        return PORT, "wss://callnum-receiver-306511771181.asia-east1.run.app/", 'Windows'  # CMB Trying
        # return PORT, "wss://callnum-receiver-410240967190.asia-east1.run.app/", 'Windows'  # CMB Live
        # return PORT, "ws://35.185.131.62:4000", 'Windows'  # Jando VM
        # return PORT, "wss://callnum-receiver-306511771181.asia-east1.run.app_/", 'Windows'  # CMB Trying  ***** æ•…æ„è¨­éŒ¯!

    if os_name == 'Linux':
        if 'K_SERVICE' in os.environ:                                                              # Cloud RUN
            PORT = int(os.environ.get("PORT", 8080))
            return PORT, "wss://callnum-receiver-306511771181.asia-east1.run.app/", 'Cloud_Run'  # CMB Trying
            # return PORT, "wss://callnum-receiver-410240967190.asia-east1.run.app/", 'Cloud_Run'  # CMB Live
        try:
            response = requests.get(
                'http://metadata.google.internal/computeMetadata/v1/',
                timeout=15,
                headers={'Metadata-Flavor': 'Google'}
            )
            if response.status_code == 200:
                return PORT, "wss://callnum-receiver-306511771181.asia-east1.run.app/", 'Compute_Engine'    # CMB Trying
                # return PORT, "wss://callnum-receiver-410240967190.asia-east1.run.app/", 'Compute_Engine'    # CMB Live
        except:
            pass
        return PORT, "ws://localhost:8088", 'Linux'
    return PORT, "ws://localhost:8088", 'Unknown'


async def main():
    """ä¸»ç¨‹å¼å…¥å£"""
    try:
        print(".\n", flush=True)
        print(".\n", flush=True)
        print(".\n", flush=True)
        await asyncio.sleep(1)
        logging.info(
            f"***** cmb-caller-frontend Ver.{VER} (GCE & GCR) é–‹å§‹åŸ·è¡Œ! *****")
        print(".\n", flush=True)
        print(".\n", flush=True)

        port, ws_url, platform_name = get_platform_config()
        if platform_name == 'Cloud_Run':
            CREDENTIALS, PROJECT_ID = default()
            print(
                f"CREDENTIALS: {CREDENTIALS}, Project ID: {PROJECT_ID}", flush=True)
            if PROJECT_ID == 'callme-398802':
                ws_url = "wss://callnum-receiver-410240967190.asia-east1.run.app/"  # CMB Live
                logging.info("CMB Live Server!")
            else:
                logging.info("CMB Trial Server!")

        logging.info(
            f'platform: {platform_name}, port: {port}, WebSocket URL: {ws_url}')
        # åˆå§‹åŒ–ä¸¦å•Ÿå‹• WebSocket Client, é€£æ¥è‡³ CMB Main Server
        ws_client = WebSocketClient(ws_url)
        asyncio.create_task(ws_client.connect())

        # åˆå§‹åŒ–ä¸¦å•Ÿå‹• WebSocket Server
        ws_server = WebSocketServer('0.0.0.0', port)
        ws_server.ws_client = ws_client
        ws_server_task = asyncio.create_task(ws_server.start())

        # æ¯åˆ†é˜ç™¼é€ç¾æœ‰ä¹‹caller_id
        periodic_task = asyncio.create_task(periodic_send_frame(ws_server))

        # ä¿æŒä¸»åŸ·è¡Œç·’é‹è¡Œ
        while True:
            await asyncio.sleep(2)

    except Exception as e:
        logging.error(f"è‡´å‘½éŒ¯èª¤: {e}")
        traceback.print_exc()
    finally:
        logging.error("cmb-caller-frontend çµæŸ")
        await ws_server.stop()  # åœæ­¢Server
        await ws_client.close()  # é—œé–‰ WebSocket é€£æ¥
        ws_server_task.cancel()  # å–æ¶ˆServerä»»å‹™
        periodic_task.cancel()  # å–æ¶ˆå®šæ™‚ä»»å‹™


if __name__ == '__main__':
    # Set up logger to log to both console and file
    # setup_logger(log_to_console=True, log_to_file=True, log_level=logging.DEBUG)
    setup_logger(log_to_console=True, log_to_file=True, log_level=logging.INFO)
    asyncio.run(main())
