#include <ArduinoWebsockets.h>
#include <Arduino.h>
#include <WiFi.h>

#include "credentials.h"

#define LED_a 17
#define LED_b 5
#define LED_c 18
#define LED_d 19
#define LED_e 21
#define LED_f 22
#define LED_g 23

#define LED_1e 16
#define LED_2e 4
#define LED_3e 15  //0 LOW(x)

#define RLED 33
#define BLED 2
#define LLH 500

const char ssid[] = "astrocorp_TEST";
const char pwd[] = "Astro1688#";

const char websockets_server_host[] = "35.187.148.66";    // GCE OK
const uint16_t websockets_server_port = 8765;  // Enter server port , GCE OK, GCR Fail
// const char websockets_server_host[] = "192.168.1.2";  // Roy PC, WiFi AP
// const uint16_t websockets_server_port = 38000;        // Enter server port

unsigned long delayStart = 0;  // the time the delay started
unsigned long ma_500ms_counter = 0;
unsigned long ma_100ms_counter = 0;
byte led_light_en = 0;

const char Caller_Prefix[] = "CMB";
char Caller_Number[] = "88888";
char Caller_ID[sizeof(Caller_Prefix) + sizeof(Caller_Number) - 1];  // -1 for null terminator

using namespace websockets;

WebsocketsClient client;
unsigned long ma_reboot_counter = 0;
unsigned long ma_counter = 0;
unsigned long ma_l1 = 20;

int fe[3] = { 0 };
int n1 = -1, n2 = -1, n3 = -1;
int pn1 = -2, pn2 = -2, pn3 = -2;
volatile bool has_interrupted = false;
hw_timer_t* timer0;
String preStr = "";
String nowStr = "";
String sendStr = "";
int matchCt = 0;

void IRAM_ATTR isr_handler() {
  has_interrupted = true;
  numberGetter();
}

void reconnect() {
  while (WiFi.status() != WL_CONNECTED || !client.available()) {
    Serial.println("Attempting to reconnect...");
    WiFi.disconnect();
    WiFi.begin(ssid, pwd);
    int retry_count = 0;
    while (WiFi.status() != WL_CONNECTED) {
      delay(500);
      Serial.print(".");
      retry_count++;
      if (retry_count > 20) {
        ESP.restart();
      }
    }
    delay(2000);  // Wait for a while before retrying websocket connection
    bool connected = client.connect(websockets_server_host, websockets_server_port, "/");
    if (connected) {
      Serial.println("Reconnected to server!");
    } else {
      Serial.println("Failed to reconnect to server.");
    }
  }
}

void setup() {
  // 初始化 Caller_ID
  strcpy(Caller_ID, Caller_Prefix);
  strcat(Caller_ID, Caller_Number);

  //io
  pinMode(RLED, OUTPUT);
  pinMode(BLED, OUTPUT);
  pinMode(LED_a, INPUT);
  pinMode(LED_b, INPUT);
  pinMode(LED_c, INPUT);
  pinMode(LED_d, INPUT);
  pinMode(LED_e, INPUT);
  pinMode(LED_f, INPUT);
  pinMode(LED_g, INPUT);
  pinMode(LED_1e, INPUT);
  pinMode(LED_2e, INPUT);
  pinMode(LED_3e, INPUT);
  pinMode(0, INPUT);
  digitalWrite(BLED, LOW);
  digitalWrite(RLED, HIGH);

  timer0 = timerBegin(1000000);         //1MHZ
  timerAlarm(timer0, 500000, true, 0);  //500ms
  timerAttachInterrupt(timer0, &isr_handler);
  attachInterrupt(digitalPinToInterrupt(LED_1e), isr_handler, RISING);
  attachInterrupt(digitalPinToInterrupt(LED_2e), isr_handler, RISING);
  attachInterrupt(digitalPinToInterrupt(LED_3e), isr_handler, RISING);

  Serial.begin(115200);

  // Connect to wifi
  WiFi.mode(WIFI_STA);  //設置WiFi模式
  WiFi.begin(ssid, pwd);
  Serial.print("WiFi connecting");
  while (WiFi.status() != WL_CONNECTED) {
    Serial.print(".");
    delay(500);
    ma_reboot_counter++;
    if (ma_reboot_counter > 20) {
      Serial.println("wifi_reboot");
      ESP.restart();
    }
  }
  Serial.print("\nIP address: ");
  Serial.println(WiFi.localIP());
  Serial.println("WiFi status:");
  Serial.println("Connected to Wifi, Connecting to server.");

  // try to connect to Websockets server
  bool connected = client.connect(websockets_server_host, websockets_server_port, "/");
  if (connected) {
    Serial.print("Connected! ");
    Serial.println(String(websockets_server_host) + ":" + String(websockets_server_port));
  } else {
    Serial.print("Server Not Connected! ");
    Serial.println(String(websockets_server_host) + ":" + String(websockets_server_port));
  }

  // run callback when messages are received
  client.onMessage([&](WebsocketsMessage message) {
    ma_l1++;
    Serial.print("Receive: ");
    Serial.println(message.data());
  });
}

int numberConverter() {
  int aa = digitalRead(LED_a);
  int bb = digitalRead(LED_b);
  int cc = digitalRead(LED_c);
  int dd = digitalRead(LED_d);
  int ee = digitalRead(LED_e);
  int ff = digitalRead(LED_f);
  int gg = digitalRead(LED_g);

  if (aa == 1 && bb == 1 && cc == 1 && dd == 1 && ee == 1 && ff == 1 && gg == 0) return 0;
  else if (aa == 0 && bb == 1 && cc == 1 && dd == 0 && ee == 0 && ff == 0 && gg == 0) return 1;
  else if (aa == 1 && bb == 1 && cc == 0 && dd == 1 && ee == 1 && ff == 0 && gg == 1) return 2;
  else if (aa == 1 && bb == 1 && cc == 1 && dd == 1 && ee == 0 && ff == 0 && gg == 1) return 3;
  else if (aa == 0 && bb == 1 && cc == 1 && dd == 0 && ee == 0 && ff == 1 && gg == 1) return 4;
  else if (aa == 1 && bb == 0 && cc == 1 && dd == 1 && ee == 0 && ff == 1 && gg == 1) return 5;
  else if (aa == 1 && bb == 0 && cc == 1 && dd == 1 && ee == 1 && ff == 1 && gg == 1) return 6;
  else if (aa == 1 && bb == 1 && cc == 1 && dd == 0 && ee == 0 && ff == 0 && gg == 0) return 7;
  else if (aa == 1 && bb == 1 && cc == 1 && dd == 1 && ee == 1 && ff == 1 && gg == 1) return 8;
  else if (aa == 1 && bb == 1 && cc == 1 && dd == 1 && ee == 0 && ff == 1 && gg == 1) return 9;
  else return -1;
}

void numberGetter() {
  const int enablePins[3] = { LED_1e, LED_2e, LED_3e };
  int* numbers[3] = { &n1, &n2, &n3 };

  for (int i = 0; i < 3; ++i) {
    int state = digitalRead(enablePins[i]);
    if (state == 1 && fe[i] == 0) {
      fe[i] = 1;
      *numbers[i] = numberConverter();
    }
    fe[i] = state;  // Update fe at the end
  }
}

void numberSend() {
  char message[100];  // 根據需要調整大小
  if (has_interrupted) {
    if (n1 >= 0 && n2 >= 0 && n3 >= 0) {
      nowStr = String(n1) + String(n2) + String(n3);
      if (nowStr == preStr) {
        matchCt++;
      } else matchCt = 1;

      preStr = nowStr;

      if (matchCt >= 3) {
        if (pn1 != n1 || pn2 != n2 || pn3 != n3) {
          pn1 = n1;
          pn2 = n2;
          pn3 = n3;
          // Serial.println(String(Caller_ID) + "," + nowStr);

          if (nowStr != sendStr && client.available()) {
            strcpy(message, Caller_ID);
            strcat(message, ",");
            strcat(message, nowStr.c_str());  // 使用 c_str() 將 String 轉換為 const char*
            Serial.println(String("Send: ") + message);
            client.send(message);
            sendStr = nowStr;
          }
          matchCt = 0;
        }
      }
      n1 = n2 = n3 = -1;  //reset n
    }

    has_interrupted = false;
  }
}

void ma_1ms_timer() {
  if ((millis() - delayStart) >= 1) {
    delayStart = millis();
    ma_500ms_counter++;
    ma_100ms_counter++;
  }
}

void ma_led_500ms() {
  if (ma_500ms_counter > LLH) {
    ma_500ms_counter = 0;
    if (led_light_en == 0) {
      digitalWrite(BLED, HIGH);
      digitalWrite(RLED, LOW);
      led_light_en = 1;
    } else {
      digitalWrite(BLED, LOW);
      digitalWrite(RLED, HIGH);
      led_light_en = 0;
    }

    if (WiFi.status() != WL_CONNECTED) {
      Serial.println("wifi GG");
      Serial.println("reboot");
      ESP.restart();
    }

    // let the websockets client check for incoming messages
    if (client.available()) {
      client.poll();
    } else {
      reconnect();
    }
  }
}

void loop() {
  ma_1ms_timer();
  ma_led_500ms();
  numberSend();
  if (digitalRead(0) == 0) {
    Serial.println("io0");
  }
}