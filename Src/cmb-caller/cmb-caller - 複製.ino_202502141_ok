char Caller_Number[] = "z0001";
// char Caller_Number[] = "z0002";

#include <ArduinoWebsockets.h>
#include <Arduino.h>
#include <WiFi.h>
#include "credentials.h"

#define VERSION "20250214_ds"

// 網路相關定義
// 定義 Local_Test，當你想切換Server時，改變這裡
#define LOCAL_TEST  // 使用 Local Server，註解掉這行就會使用遠端Server
#ifndef LOCAL_TEST
const char* websockets_server_host = "35.187.148.66";
const uint16_t websockets_server_port = 8765;
#else
const char* websockets_server_host = "192.168.1.2";  // Windows Local
const uint16_t websockets_server_port = 38000;       // Windows Local
#endif

// LED 定義
#define LED_a 17
#define LED_b 5
#define LED_c 18
#define LED_d 19
#define LED_e 21
#define LED_f 22
#define LED_g 23
#define LED_1e 16
#define LED_2e 4
#define LED_3e 15

#define LED_RED 33
#define LED_GREEN 32
// #define LED_BLUE 2

// 系統狀態枚舉
enum SystemState {
  STATE_INIT,
  STATE_WIFI_CONNECTING,
  STATE_WIFI_CONNECTED,
  STATE_WEBSOCKET_CONNECTING,
  STATE_WEBSOCKET_CONNECTED,
  STATE_ERROR
};

// 系統狀態結構
struct Status {
  SystemState state;
  unsigned long lastStateChange;
  String lastError;
  int wifiAttempts;
  int websocketAttempts;
  String currentSSID;
} status;

const int numNetworks = sizeof(wifiNetworks) / sizeof(wifiNetworks[0]);

// 計時器和網路相關
const long WIFI_TIMEOUT = 7000;          // WiFi 連接超時時間 (原10000)
const long WS_TIMEOUT = 5000;            // WebSocket 連接超時時間 (5000)
const long STATE_UPDATE_INTERVAL = 500;  // 狀態更新間隔 (500)
const long PING_INTERVAL = 30000;        // Ping 間隔 (30000)
// const long PONG_INTERVAL = 10000;        // Pong 間隔 (10000)
const long ON_MESSAGE_TIMEOUT = 10000;  // onMessage 超時時間 (10 秒)
//const long printInterval = 600000;       // 設定時間間隔為10分鐘 (600000毫秒)
const long printInterval = 60000;          // 設定時間間隔為1分鐘 (600000毫秒) !!!@@@
const long CHECK_NUMBER_INTERVAL = 100;    // (100)
const long CHECK_DISPLAY_INTERVAL = 100;  // (100)
// 系統變數
unsigned long lastPING = 0;
unsigned long delayStart = 0;
// unsigned long ma_500ms_counter = 0;
// byte led_light_en = 0;
int currentNetwork = 0;
unsigned long onMessage_time = 0;        // 宣告 onMessage_time 為全域變數
unsigned long lastPrintTime = millis();  // 儲存上次印出訊息的時間
unsigned long lastCheckNumber = 0;
unsigned long InterruptCount = 0;
unsigned long scanDisplayCount = 0;
unsigned long currentMillis = millis();
volatile unsigned long lastScanDisplayTime = 0;
volatile int scanCallCount = 0;

// Caller 相關定義
const char Caller_Prefix[] = "CMB";
char Caller_SSID[sizeof(Caller_Prefix) + sizeof(Caller_Number) - 1];

// 數字顯示相關
int fe[3] = { 0 };
int n1 = -1, n2 = -1, n3 = -1;
int pn1 = -2, pn2 = -2, pn3 = -2;
volatile bool has_interrupted = false;
hw_timer_t* timer0;
String preStr = "";
String nowStr = "";
String sendStr = "";
int matchCt = 0;

using namespace websockets;
WebsocketsClient client;

// 更新系統狀態
void updateSystemState(SystemState newState, const String& error = "") {
  status.state = newState;
  status.lastStateChange = millis();
  if (error.length() > 0) {
    status.lastError = error;
    Serial.println("\nError: " + error);
  }

  // 更新 LED 狀態
  switch (newState) {
    case STATE_INIT:
      Serial.printf("S0 ", newState);  // 0
      digitalWrite(LED_RED, LOW);      // 紅燈亮
      digitalWrite(LED_GREEN, HIGH);   // 綠燈滅
      break;
    case STATE_WIFI_CONNECTING:
      Serial.printf("S1 ", newState);                // 1
      digitalWrite(LED_RED, !digitalRead(LED_RED));  // 紅燈快速閃爍
      digitalWrite(LED_GREEN, HIGH);                 // 綠燈滅
      break;
    case STATE_WIFI_CONNECTED:
      Serial.printf("S2 ", newState);  // 2
      digitalWrite(LED_RED, LOW);      // 紅燈亮
      digitalWrite(LED_GREEN, HIGH);   // 綠燈滅
      break;
    case STATE_WEBSOCKET_CONNECTING:
      Serial.printf("S3 ", newState);                 // 3 -> 黃燈慢速閃爍
      digitalWrite(LED_RED, !digitalRead(LED_RED));   // 紅燈慢速閃爍
      digitalWrite(LED_GREEN, digitalRead(LED_RED));  // 綠燈慢速閃爍
      break;
    case STATE_WEBSOCKET_CONNECTED:  // 4
      Serial.printf("S4 ", newState);
      digitalWrite(LED_RED, HIGH);   // 紅燈滅
      digitalWrite(LED_GREEN, LOW);  // 綠燈亮
      break;
    case STATE_ERROR:  // 不變動LED，以免影響其它狀態顯示.
      // Serial.printf("S5 ", newState);
      // digitalWrite(LED_RED, LOW);  // 紅燈亮
      // digitalWrite(LED_GREEN, HIGH);   // 綠燈滅
      break;
  }
}

// 中斷處理函數
// void IRAM_ATTR handleInterrupt() {
//   has_interrupted = true;
//   InterruptCount += 1;
//   // scanDisplayDigits();  // 數字掃描邏輯!!!@@@
//   scanDisplayDigits();  // 數字掃描邏輯!!!@@@
// }

void IRAM_ATTR handleInterrupt() {
  currentMillis = millis();
  InterruptCount += 1;

  // 檢查是否超過100毫秒
  if (currentMillis - lastScanDisplayTime >= CHECK_DISPLAY_INTERVAL) {
    lastScanDisplayTime = currentMillis;
    scanCallCount = 0;  // 重置計數器
  }

  // 只在計數器小於3時呼叫scanDisplayDigits
  if (scanCallCount < 3) {
    has_interrupted = true;
    scanCallCount++;
    scanDisplayDigits();  // 數字掃描
  }
}

// 初始化函數
void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println("\n\n----------------------------------\n");
  Serial.printf("cmb_caller Ver:%s, Caller Number %s.\n", VERSION, Caller_Number);

  // 初始化 Caller_SSID
  strcpy(Caller_SSID, Caller_Prefix);
  strcat(Caller_SSID, Caller_Number);
  wifiNetworks[0].ssid = Caller_SSID;
  wifiNetworks[0].password = "88888888";

  // IO 初始化
  pinMode(LED_RED, OUTPUT);
  pinMode(LED_GREEN, OUTPUT);
  updateSystemState(STATE_INIT);

  const int inputs[] = { LED_a, LED_b, LED_c, LED_d, LED_e, LED_f, LED_g,
                         LED_1e, LED_2e, LED_3e, 0 };
  for (int pin : inputs) {
    pinMode(pin, INPUT);
  }

  // Timer 初始化
  timer0 = timerBegin(1000000);         // 1MHZ
  timerAlarm(timer0, 500000, true, 0);  // 500ms
  timerAttachInterrupt(timer0, &handleInterrupt);

  // 設置外部中斷
  attachInterrupt(digitalPinToInterrupt(LED_1e), handleInterrupt, RISING);
  attachInterrupt(digitalPinToInterrupt(LED_2e), handleInterrupt, RISING);
  attachInterrupt(digitalPinToInterrupt(LED_3e), handleInterrupt, RISING);

  // 網路初始化
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false);  // 禁用 Wi-Fi 休眠
  bool result = false;
  for (int i = 0; i < numNetworks; i++) {  // 從 wifiNetworks 取得 ssid & password.
    delay(500);
    currentNetwork = i;
    result = connectToWiFi(wifiNetworks[i].ssid, wifiNetworks[i].password);
    if (result) {
      break;
    }
  }
  if (result == false)
    currentNetwork = 0;

  // WebSocket Event 處理
  client.onEvent(onEventsCallback);

  // WebSocket 消息處理
  client.onMessage(onMessageCallback);

  Serial.println("Setup finish!");
}


// 數字轉換函數
int convertToNumber() {
  const int pins[] = { LED_a, LED_b, LED_c, LED_d, LED_e, LED_f, LED_g };
  int values[7];

  for (int i = 0; i < 7; i++) {
    values[i] = digitalRead(pins[i]);
  }

  // 七段顯示器解碼邏輯
  struct {
    int pattern[7];
    int number;
  } patterns[] = {
    { { 1, 1, 1, 1, 1, 1, 0 }, 0 },
    { { 0, 1, 1, 0, 0, 0, 0 }, 1 },
    { { 1, 1, 0, 1, 1, 0, 1 }, 2 },
    { { 1, 1, 1, 1, 0, 0, 1 }, 3 },
    { { 0, 1, 1, 0, 0, 1, 1 }, 4 },
    { { 1, 0, 1, 1, 0, 1, 1 }, 5 },
    { { 1, 0, 1, 1, 1, 1, 1 }, 6 },
    { { 1, 1, 1, 0, 0, 0, 0 }, 7 },
    { { 1, 1, 1, 1, 1, 1, 1 }, 8 },
    { { 1, 1, 1, 1, 0, 1, 1 }, 9 }
  };

  for (const auto& p : patterns) {
    bool match = true;
    for (int i = 0; i < 7; i++) {
      if (values[i] != p.pattern[i]) {
        match = false;
        break;
      }
    }
    if (match) return p.number;
  }

  return -1;
}

// WiFi 連接函數
bool connectToWiFi(const char* ssid, const char* pwd) {
  updateSystemState(STATE_WIFI_CONNECTING);
  Serial.printf("Connecting to WiFi: %s\n", ssid);

  status.currentSSID = ssid;
  WiFi.begin(ssid, pwd);

  unsigned long startTime = millis();
  while (WiFi.status() != WL_CONNECTED) {
    if (millis() - startTime > WIFI_TIMEOUT) {
      updateSystemState(STATE_ERROR, "WiFi connection timeout");
      status.wifiAttempts++;
      return false;
    }
    updateSystemState(STATE_WIFI_CONNECTING);
    delay(100);  // LED 閃動
  }
  Serial.printf("\nConnected to WiFi. SSID: %s, IP: %s\n", ssid, WiFi.localIP().toString().c_str());
  updateSystemState(STATE_WIFI_CONNECTED);
  status.wifiAttempts = 0;
  return true;
}

// WebSocket 連接函數
bool connectToWebSocket() {
  updateSystemState(STATE_WEBSOCKET_CONNECTING);
  Serial.printf("Connecting to WebSocket server(%i)\n", status.websocketAttempts);

  bool connected = client.connect(websockets_server_host, websockets_server_port, "/");
  if (connected) {
    Serial.println("Connected to WebSocket server");
    updateSystemState(STATE_WEBSOCKET_CONNECTED);
    status.websocketAttempts = 0;
    return true;
  }

  updateSystemState(STATE_ERROR, "WebSocket connection failed");
  status.websocketAttempts++;
  return false;
}

void scanDisplayDigits() {
  const int enablePins[3] = { LED_1e, LED_2e, LED_3e };
  int* numbers[3] = { &n1, &n2, &n3 };

  scanDisplayCount += 1;
  for (int i = 0; i < 3; ++i) {
    int state = digitalRead(enablePins[i]);
    if (state == 1 && fe[i] == 0) {
      fe[i] = 1;
      *numbers[i] = convertToNumber();
    }
    fe[i] = state;
  }
}

// // 數字發送函數
// void sendCallerNumber() {
//   if (!has_interrupted)
//     return;

//   if (n1 >= 0 && n2 >= 0 && n3 >= 0) {
//     nowStr = String(n1) + String(n2) + String(n3);
//     if (nowStr == preStr) {
//       matchCt++;
//     } else {
//       matchCt = 1;
//     }

//     preStr = nowStr;

//     if (matchCt >= 3) {
//       if (pn1 != n1 || pn2 != n2 || pn3 != n3) {
//         pn1 = n1;
//         pn2 = n2;
//         pn3 = n3;

//         if (nowStr != sendStr && client.available()) {
//           String message = String(Caller_Number) + "," + nowStr;
//           Serial.println("Send: " + message);
//           client.send(message);
//           sendStr = nowStr;
//           onMessage_time = millis();  // 重置 onMessage 計時器
//         }
//         matchCt = 0;
//       }
//     }
//     n1 = n2 = n3 = -1;
//   }
//   has_interrupted = false;
// }

void sendCallerNumber() {
  if (!has_interrupted) return;

  if (n1 >= 0 && n2 >= 0 && n3 >= 0) {
    nowStr = String(n1) + String(n2) + String(n3);
    matchCt = (nowStr == preStr) ? matchCt + 1 : 1;
    preStr = nowStr;

    if (matchCt >= 3 && (pn1 != n1 || pn2 != n2 || pn3 != n3)) {
      pn1 = n1;
      pn2 = n2;
      pn3 = n3;

      if (nowStr != sendStr && client.available()) {
        String message = String(Caller_Number) + "," + nowStr;
        Serial.println("Send: " + message);
        client.send(message);
        sendStr = nowStr;
        onMessage_time = millis();  // 重置 onMessage 計時器
      }
      matchCt = 0;
    }
    n1 = n2 = n3 = -1;
  }
  has_interrupted = false;
}

// 檢查連接狀態
void checkConnections() {
  // 檢查 WiFi 連接
  if (WiFi.status() != WL_CONNECTED) {
    Serial.println("WiFi.status() != WL_CONNECTED");
    if (status.state != STATE_WIFI_CONNECTING) {
      Serial.println("status.state != STATE_WIFI_CONNECTING");
      bool result = connectToWiFi(wifiNetworks[currentNetwork].ssid, wifiNetworks[currentNetwork].password);
      if (!result)  // 如果連線成功，如斷線先繼續試此一 SSID.
        currentNetwork = (currentNetwork + 1) % numNetworks;
    }
    return;
  }

  // 檢查 WebSocket 連接
  if (!client.available()) {
    if (status.state != STATE_WEBSOCKET_CONNECTING) {
      Serial.println("\nconnectToWebSocket");
      connectToWebSocket();
    } else {
      // 如果已經在連接中，但超過一定時間未連接成功，重新嘗試連接
      if (millis() - status.lastStateChange > WS_TIMEOUT) {
        Serial.println("WebSocket connection timeout, retrying...");
        client.close();
        updateSystemState(STATE_WEBSOCKET_CONNECTING);
        connectToWebSocket();
      }
    }
    return;
  }



  client.poll();
}

void onEventsCallback(WebsocketsEvent event, String data) {
  // Serial.println("");
  if (event == WebsocketsEvent::ConnectionOpened) {
    Serial.println("E:Connection Opened");
  } else if (event == WebsocketsEvent::ConnectionClosed) {
    Serial.println("\nE:Connection Closed");
  } else if (event == WebsocketsEvent::GotPing) {
    Serial.print("I");
    client.pong();
    Serial.print("o ");
  } else if (event == WebsocketsEvent::GotPong) {
    // Serial.println("\nE:Got a Pong!");
    Serial.print("O");
  }
}

void onMessageCallback(WebsocketsMessage message) {
  // Serial.println("onMessage");
  onMessage_time = 0;
  if (message.data() != "pong")
    Serial.println("Received: " + message.data());
  else
    Serial.print(". ");
}

// 在全域變數區域加入
#define MINIMUM_HEAP 20000  // 設定最小堆積記憶體門檻值（依需求調整）

// 記憶體檢查函數
void checkMemory() {
  uint32_t freeHeap = ESP.getFreeHeap();
  Serial.printf("Free Heap: %u bytes\n", freeHeap);

  if (freeHeap < MINIMUM_HEAP) {
    updateSystemState(STATE_ERROR, "Low memory warning");
  }
}

// 發送 Ping_EX
void Ping_EX() {
  String message = String(Caller_Number) + "," + "ping" + "," + sendStr;
  if (client.ping()) {
    // Serial.println("Ping sent successfully");
    Serial.print("i");
  } else {
    Serial.println("Ping failed!!!");
  }
  client.send(message);
  lastPING = millis();
  onMessage_time = millis();  // 重置 onMessage 計時器
}

void check_system() {
  Serial.printf("InterruptCount:%lu, scanDisplayCount:%lu\n", InterruptCount, scanDisplayCount);
  checkMemory();
}

// 主循環
void loop() {
  static unsigned long lastCheck = 0;
  // unsigned long currentMillis = millis();
  currentMillis = millis();

  // 定期檢查連接狀態
  if (currentMillis - lastCheck >= STATE_UPDATE_INTERVAL) {
    lastCheck = currentMillis;
    checkConnections();
  }

  // 處理 Caller 數字發送
  currentMillis = millis();
  if (currentMillis - lastCheckNumber >= CHECK_NUMBER_INTERVAL) {
    lastCheckNumber = currentMillis;
    sendCallerNumber();
    // 檢查重置按鈕
    if (digitalRead(0) == 0) {
      Serial.println("IO0 button pressed");
    }
  }

  // 發送 ping
  currentMillis = millis();
  if (currentMillis - lastPING >= PING_INTERVAL) {
    lastPING = currentMillis;
    Ping_EX();
  }

  // 檢查 onMessage 超時
  currentMillis = millis();
  if ((onMessage_time != 0) && (currentMillis - onMessage_time > ON_MESSAGE_TIMEOUT)) {
    Serial.println("onMessage timeout, reconnecting WebSocket...");
    client.close();
    updateSystemState(STATE_WEBSOCKET_CONNECTING);
    connectToWebSocket();
    onMessage_time = currentMillis;  // 重置計時器
  }

  if (currentMillis - lastPrintTime >= printInterval) {
    lastPrintTime = currentMillis;  // 更新上次印出訊息的時間
    Serial.println();               // 印出換行
    // checkMemory();
    check_system();
  }
}