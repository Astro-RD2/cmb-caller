char Caller_Number[] = "z0001";
// char Caller_Number[] = "z0002";

#include <ArduinoWebsockets.h>
#include <Arduino.h>
#include <WiFi.h>
#include "credentials.h"

#include <Arduino.h>
#include "freertos/FreeRTOS.h"
#include "freertos/task.h"
#include "esp_freertos_hooks.h"
#include "sdkconfig.h"


#define VERSION "20250217"

// 網路相關定義
// 定義 Local_Test，當你想切換Server時，改變這裡
#define LOCAL_TEST  // 使用 Local Server，註解掉這行就會使用遠端Server
#ifndef LOCAL_TEST
const char* websockets_server_host = "35.187.148.66";  // VM
const uint16_t websockets_server_port = 8765;          // VM
#else
const char* websockets_server_host = "192.168.1.2";  // Windows Local
const uint16_t websockets_server_port = 38000;       // Windows Local
#endif

// LED 定義
#define LED_a 17
#define LED_b 5
#define LED_c 18
#define LED_d 19
#define LED_e 21
#define LED_f 22
#define LED_g 23
#define LED_1e 16
#define LED_2e 4
#define LED_3e 15

#define LED_RED 33
#define LED_GREEN 32
// #define LED_BLUE 2

/*
// 系統狀態枚舉
enum SystemState {
  STATE_INIT,
  STATE_WIFI_CONNECTING,
  STATE_WIFI_CONNECTED,
  STATE_WEBSOCKET_CONNECTING,
  STATE_WEBSOCKET_CONNECTED,
  STATE_ERROR
};

// 系統狀態結構
struct Status {
  SystemState state;
  unsigned long lastStateChange;
  String lastError;
  int wifiAttempts;
  int websocketAttempts;
  String currentSSID;
} status;
*/

const int numNetworks = sizeof(wifiNetworks) / sizeof(wifiNetworks[0]);

// 計時器和網路相關
const long WIFI_TIMEOUT = 7000;          // WiFi 連接超時時間 (原10000)
const long WS_TIMEOUT = 5000;            // WebSocket 連接超時時間 (5000)
const long STATE_UPDATE_INTERVAL = 500;  // 狀態更新間隔 (500)
const long PING_INTERVAL = 30000;        // Ping 間隔 (30000)
// const long PONG_INTERVAL = 10000;        // Pong 間隔 (10000)
const long ON_MESSAGE_TIMEOUT = 10000;  // onMessage 超時時間 (10 秒)
//const long printInterval = 600000;       // 設定時間間隔為10分鐘 (600000毫秒)
const long printInterval = 60000;         // 設定時間間隔為1分鐘 (600000毫秒) !!!@@@
const long CHECK_NUMBER_INTERVAL = 100;   // (100)
const long CHECK_DISPLAY_INTERVAL = 200;  // (100) !!!@@@
const long CALC_CPU_LOAD_INTERVAL = 10000;
const long SCAN_NUM = 3;  // (3 or 6)
// 系統變數
unsigned long lastPING = 0;
unsigned long delayStart = 0;
// unsigned long ma_500ms_counter = 0;
// byte led_light_en = 0;
int currentNetwork = 0;
volatile unsigned long onMessage_time = 0;  // 宣告 onMessage_time 為全域變數
// unsigned long lastPrintTime = millis();  // 儲存上次印出訊息的時間
unsigned long lastPrintTime = millis() - printInterval;  // 儲存上次印出訊息的時間
unsigned long lastCheckNumber = 0;
volatile unsigned long InterruptCount = 0;
volatile unsigned long scanDisplayCount = 0;
volatile unsigned long currentMillis = millis();
volatile unsigned long lastScanDisplayTime = 0;
volatile int scanCallCount = 0;
// Caller 相關定義
const char Caller_Prefix[] = "CMB";
char Caller_SSID[sizeof(Caller_Prefix) + sizeof(Caller_Number) - 1];
// 變數用於儲存 CPU 負載量
volatile uint32_t idleCount[portNUM_PROCESSORS] = { 0 };
volatile uint32_t idleCountLast[portNUM_PROCESSORS] = { 0 };


// 數字顯示相關
int fe[3] = { 0 };
volatile int n1 = -1, n2 = -1, n3 = -1;
int pn1 = -2, pn2 = -2, pn3 = -2;
volatile bool has_interrupted = false;
hw_timer_t* timer0;
String preStr = "";
String nowStr = "";
String sendStr = "";
int matchCt = 0;

using namespace websockets;
WebsocketsClient client;

void scanDisplayDigits();



void IRAM_ATTR handleInterrupt() {
  // currentMillis = millis();
  InterruptCount += 1;

  // 檢查是否超過100毫秒
  if (currentMillis - lastScanDisplayTime >= CHECK_DISPLAY_INTERVAL) {
    lastScanDisplayTime = currentMillis;
    scanCallCount = 0;  // 重置計數器
  }

  // 只在計數器小於3時呼叫scanDisplayDigits
  if (scanCallCount < SCAN_NUM) {
    has_interrupted = true;
    scanCallCount++;
    scanDisplayDigits();  // 數字掃描
  }
}

// IDLE 迴圈函數
bool vApplicationIdleHook(void) {
  idleCount[xPortGetCoreID()]++;
  return true;
}



// 系統狀態枚舉
enum SystemState {
  STATE_INIT,
  STATE_WIFI_CONNECTING,
  STATE_WIFI_CONNECTED,
  STATE_WEBSOCKET_CONNECTING,
  STATE_WEBSOCKET_CONNECTED,
  STATE_ERROR
};

// LED 控制結構
struct LedState {
  bool isOn;                 // LED 當前狀態
  bool isBlinking;           // 是否閃爍
  unsigned long onTime;      // 亮持續時間 (毫秒)
  unsigned long offTime;     // 滅持續時間 (毫秒)
  unsigned long lastToggle;  // 最後切換時間
};

// 系統狀態結構
struct Status {
  SystemState state;
  unsigned long lastStateChange;
  String lastError;
  int wifiAttempts;
  int websocketAttempts;
  String currentSSID;
} status;

// LED 配置
struct LedConfig {
  LedState red;
  LedState green;
} ledConfigs[6];

// unsigned long currentMillis = 0;
TimerHandle_t redTimer;
TimerHandle_t greenTimer;

// 初始化 LED 設定
void initLedConfigs() {
  // STATE_INIT, 0
  ledConfigs[STATE_INIT].red = { true, false, 0, 0, 0 };     // 紅燈持續亮
  ledConfigs[STATE_INIT].green = { false, false, 0, 0, 0 };  // 綠燈持續滅

  // STATE_WIFI_CONNECTING, 1
  ledConfigs[STATE_WIFI_CONNECTING].red = { false, true, 100, 100, 0 };  // 紅燈快速閃爍
  ledConfigs[STATE_WIFI_CONNECTING].green = { false, false, 0, 0, 0 };   // 綠燈持續滅

  // STATE_WIFI_CONNECTED, 2
  ledConfigs[STATE_WIFI_CONNECTED].red = { true, false, 0, 0, 0 };     // 紅燈持續亮
  ledConfigs[STATE_WIFI_CONNECTED].green = { false, false, 0, 0, 0 };  // 綠燈持續滅

  // STATE_WEBSOCKET_CONNECTING, 3
  ledConfigs[STATE_WEBSOCKET_CONNECTING].red = { false, true, 700, 700, 0 };    // 紅燈慢速閃爍
  ledConfigs[STATE_WEBSOCKET_CONNECTING].green = { false, true, 700, 700, 0 };  // 綠燈慢速閃爍

  // STATE_WEBSOCKET_CONNECTED, 4
  ledConfigs[STATE_WEBSOCKET_CONNECTED].red = { false, false, 0, 0, 0 };   // 紅燈持續滅
  ledConfigs[STATE_WEBSOCKET_CONNECTED].green = { true, false, 0, 0, 0 };  // 綠燈持續亮

  // STATE_ERROR, 5
  ledConfigs[STATE_ERROR].red = { false, false, 0, 0, 0 };    // 紅燈滅
  ledConfigs[STATE_ERROR].green = { false, false, 0, 0, 0 };  // 綠燈滅
}

// 更新 LED 狀態
void updateLEDState() {
  LedState* redState = &ledConfigs[status.state].red;
  LedState* greenState = &ledConfigs[status.state].green;

  // 更新紅燈計時器 ID
  vTimerSetTimerID(redTimer, redState);
  // 更新綠燈計時器 ID
  vTimerSetTimerID(greenTimer, greenState);

  // 立即觸發一次計時器回調，以應用新的 LED 狀態
  blinkLED(redTimer);
  blinkLED(greenTimer);
}

// 更新系統狀態
void updateSystemState(SystemState newState, const String& error = "") {
  // 打印狀態
  Serial.printf("S%i ", newState);
  if (newState == 5) {
    Serial.printf(" Pass! ");
    return;
  }
  status.state = newState;
  status.lastStateChange = currentMillis;
  if (error.length() > 0) {
    status.lastError = error;
    Serial.println("\nError: " + error);
  }
  // 更新 LED 狀態
  updateLEDState();
}

// LED 閃動函數
void blinkLED(TimerHandle_t xTimer) {
  currentMillis = millis();
  LedState* ledState = (LedState*)pvTimerGetTimerID(xTimer);

  if (ledState->isBlinking) {
    if (ledState->isOn && (currentMillis - ledState->lastToggle >= ledState->onTime)) {
      ledState->isOn = false;
      ledState->lastToggle = currentMillis;
      digitalWrite(ledState == &ledConfigs[status.state].red ? LED_RED : LED_GREEN, HIGH);  // LED滅
    } else if (!ledState->isOn && (currentMillis - ledState->lastToggle >= ledState->offTime)) {
      ledState->isOn = true;
      ledState->lastToggle = currentMillis;
      digitalWrite(ledState == &ledConfigs[status.state].red ? LED_RED : LED_GREEN, LOW);  // LED亮
    }
  } else {
    digitalWrite(ledState == &ledConfigs[status.state].red ? LED_RED : LED_GREEN, ledState->isOn ? LOW : HIGH);  // LED亮滅相反
  }
}


// 初始化函數
void setup() {
  Serial.begin(115200);
  delay(100);
  Serial.println();
  Serial.println();
  Serial.println();
  Serial.println("----------------------------------\n");
  Serial.printf("cmb_caller Ver:%s, Caller Number %s.\n", VERSION, Caller_Number);

  // 初始化 Caller_SSID
  strcpy(Caller_SSID, Caller_Prefix);
  strcat(Caller_SSID, Caller_Number);
  wifiNetworks[0].ssid = Caller_SSID;
  wifiNetworks[0].password = "88888888";

#ifdef LOCAL_TEST
  Serial.println("本地測試模式!!!");
  wifiNetworks[0].ssid = "";
  wifiNetworks[0].password = "";
  wifiNetworks[2].ssid = "";
  wifiNetworks[2].password = "";
#endif


  // IO 初始化
  pinMode(LED_RED, OUTPUT);
  pinMode(LED_GREEN, OUTPUT);

  // 初始化 LED 配置
  initLedConfigs();
  // 創建 FreeRTOS 計時器
  redTimer = xTimerCreate("RedLEDTimer", pdMS_TO_TICKS(100), pdTRUE, &ledConfigs[STATE_INIT].red, blinkLED);
  greenTimer = xTimerCreate("GreenLEDTimer", pdMS_TO_TICKS(100), pdTRUE, &ledConfigs[STATE_INIT].green, blinkLED);
  // 啟動計時器
  xTimerStart(redTimer, 0);
  xTimerStart(greenTimer, 0);

  updateSystemState(STATE_INIT);

  const int inputs[] = { LED_a, LED_b, LED_c, LED_d, LED_e, LED_f, LED_g,
                         LED_1e, LED_2e, LED_3e, 0 };
  for (int pin : inputs) {
    pinMode(pin, INPUT);
  }

  // Timer 初始化
  timer0 = timerBegin(1000000);         // 1MHZ
  timerAlarm(timer0, 500000, true, 0);  // 500ms
  timerAttachInterrupt(timer0, &handleInterrupt);

  // 設置外部中斷
  attachInterrupt(digitalPinToInterrupt(LED_1e), handleInterrupt, RISING);
  attachInterrupt(digitalPinToInterrupt(LED_2e), handleInterrupt, RISING);
  attachInterrupt(digitalPinToInterrupt(LED_3e), handleInterrupt, RISING);

  // 網路初始化
  WiFi.mode(WIFI_STA);
  WiFi.setSleep(false);  // 禁用 Wi-Fi 休眠
  bool result = false;
  for (int i = 0; i < numNetworks; i++) {  // 從 wifiNetworks 取得 ssid & password.
    delay(500);
    currentNetwork = i;
    if (wifiNetworks[i].ssid == "") {
      Serial.printf("wifiNetworks %i pass!\n", i);
      continue;
    }
    result = connectToWiFi(wifiNetworks[i].ssid, wifiNetworks[i].password);
    if (result) {
      break;
    }
  }
  if (result == false)
    currentNetwork = 0;


  // 設定 IDLE HOOK 函數
  esp_register_freertos_idle_hook_for_cpu(vApplicationIdleHook, 0);
  esp_register_freertos_idle_hook_for_cpu(vApplicationIdleHook, 1);

  // WebSocket Event 處理
  client.onEvent(onEventsCallback);

  // WebSocket 消息處理
  client.onMessage(onMessageCallback);

  Serial.println("Setup finish!");
}


// 數字轉換函數
int convertToNumber() {
  const int pins[] = { LED_a, LED_b, LED_c, LED_d, LED_e, LED_f, LED_g };
  int values[7];

  for (int i = 0; i < 7; i++) {
    values[i] = digitalRead(pins[i]);
  }

  // 七段顯示器解碼邏輯
  struct {
    int pattern[7];
    int number;
  } patterns[] = {
    { { 1, 1, 1, 1, 1, 1, 0 }, 0 },
    { { 0, 1, 1, 0, 0, 0, 0 }, 1 },
    { { 1, 1, 0, 1, 1, 0, 1 }, 2 },
    { { 1, 1, 1, 1, 0, 0, 1 }, 3 },
    { { 0, 1, 1, 0, 0, 1, 1 }, 4 },
    { { 1, 0, 1, 1, 0, 1, 1 }, 5 },
    { { 1, 0, 1, 1, 1, 1, 1 }, 6 },
    { { 1, 1, 1, 0, 0, 0, 0 }, 7 },
    { { 1, 1, 1, 1, 1, 1, 1 }, 8 },
    { { 1, 1, 1, 1, 0, 1, 1 }, 9 }
  };

  for (const auto& p : patterns) {
    bool match = true;
    for (int i = 0; i < 7; i++) {
      if (values[i] != p.pattern[i]) {
        match = false;
        break;
      }
    }
    if (match) return p.number;
  }

  return -1;
}

// WiFi 連接函數
bool connectToWiFi(const char* ssid, const char* pwd) {
  updateSystemState(STATE_WIFI_CONNECTING);
  Serial.printf("Connecting to WiFi: %s\n", ssid);

  status.currentSSID = ssid;
  WiFi.begin(ssid, pwd);

  unsigned long startTime = millis();
  while (WiFi.status() != WL_CONNECTED) {
    if (millis() - startTime > WIFI_TIMEOUT) {
      updateSystemState(STATE_ERROR, "WiFi connection timeout");
      status.wifiAttempts++;
      return false;
    }
    updateSystemState(STATE_WIFI_CONNECTING);
    delay(100);  // LED 閃動
  }
  Serial.printf("\nConnected to WiFi. SSID: %s, IP: %s\n", ssid, WiFi.localIP().toString().c_str());
  updateSystemState(STATE_WIFI_CONNECTED);
  status.wifiAttempts = 0;
  return true;
}

// WebSocket 連接函數
bool connectToWebSocket() {
  updateSystemState(STATE_WEBSOCKET_CONNECTING);
  Serial.printf("Connecting to WebSocket server(%i)\n", status.websocketAttempts);
  bool connected = client.connect(websockets_server_host, websockets_server_port, "/");
  if (connected) {
    Serial.println("Connected to WebSocket server");
    updateSystemState(STATE_WEBSOCKET_CONNECTED);
    status.websocketAttempts = 0;
    return true;
  }
  updateSystemState(STATE_ERROR, "WebSocket connection failed!");
  status.websocketAttempts++;
  return false;
}

void scanDisplayDigits() {
  const int enablePins[3] = { LED_1e, LED_2e, LED_3e };
  volatile int* numbers[3] = { &n1, &n2, &n3 };

  scanDisplayCount += 1;
  for (int i = 0; i < 3; ++i) {
    int state = digitalRead(enablePins[i]);
    if (state == 1 && fe[i] == 0) {
      fe[i] = 1;
      *numbers[i] = convertToNumber();
    }
    fe[i] = state;
  }
}

// 數字發送函數
void sendCallerNumber() {
  if (!has_interrupted) return;

  if (n1 >= 0 && n2 >= 0 && n3 >= 0) {
    nowStr = String(n1) + String(n2) + String(n3);
    matchCt = (nowStr == preStr) ? matchCt + 1 : 1;
    preStr = nowStr;

    if (matchCt >= 3 && (pn1 != n1 || pn2 != n2 || pn3 != n3)) {
      Serial.println("*");
      pn1 = n1;
      pn2 = n2;
      pn3 = n3;
      if (nowStr != sendStr && client.available()) {
        String message = String(Caller_Number) + "," + nowStr;
        Serial.println("Send: " + message);
        client.send(message);
        sendStr = nowStr;
        onMessage_time = currentMillis;  // 重置 onMessage 計時器
      }
      matchCt = 0;
    }
    n1 = n2 = n3 = -1;
  }
  has_interrupted = false;
}

// 檢查連接狀態
void checkConnections() {
  // 檢查 WiFi 連接
  if (WiFi.status() != WL_CONNECTED) {
    // Serial.println("WiFi.status() != WL_CONNECTED");
    if (status.state != STATE_WIFI_CONNECTING) {
      Serial.println("status.state != STATE_WIFI_CONNECTING");
      bool result = false;
      if (wifiNetworks[currentNetwork].ssid != "")
        result = connectToWiFi(wifiNetworks[currentNetwork].ssid, wifiNetworks[currentNetwork].password);
      if (!result) {  // 如果連線成功，如斷線先繼續試此一 SSID.
        currentNetwork = (currentNetwork + 1) % numNetworks;
        vTaskDelay(pdMS_TO_TICKS(1000));  // 或使用 delay(10)
      }
    }
    return;
  }

  // 檢查 WebSocket 連接
  if (!client.available()) {
    if (status.state != STATE_WEBSOCKET_CONNECTING) {
      Serial.println("\nconnectToWebSocket");
      connectToWebSocket();
    } else {
      // 如果已經在連接中，但超過一定時間未連接成功，重新嘗試連接
      if (currentMillis - status.lastStateChange > WS_TIMEOUT) {
        Serial.println("WebSocket connection timeout, retrying...");
        client.close();
        updateSystemState(STATE_WEBSOCKET_CONNECTING);
        connectToWebSocket();
      }
    }
    return;
  }



  client.poll();
}

void onEventsCallback(WebsocketsEvent event, String data) {
  // Serial.println("");
  if (event == WebsocketsEvent::ConnectionOpened) {
    Serial.println("E:Connection Opened");
  } else if (event == WebsocketsEvent::ConnectionClosed) {
    Serial.println("\nE:Connection Closed");
  } else if (event == WebsocketsEvent::GotPing) {
    Serial.print("I");
    client.pong();
    Serial.print("o ");
  } else if (event == WebsocketsEvent::GotPong) {
    // Serial.println("\nE:Got a Pong!");
    Serial.print("O");
  }
}

void onMessageCallback(WebsocketsMessage message) {
  // Serial.println("onMessage");
  onMessage_time = 0;
  if (message.data() != "pong")
    Serial.println("Received: " + message.data());
  else
    Serial.print(". ");
}

// 在全域變數區域加入
#define MINIMUM_HEAP 20000  // 設定最小堆積記憶體門檻值（依需求調整）

// 記憶體檢查函數
void checkMemory() {
  uint32_t freeHeap = ESP.getFreeHeap();
  Serial.printf("Free Heap: %u bytes\n", freeHeap);
  if (freeHeap < MINIMUM_HEAP) {
    updateSystemState(STATE_ERROR, "Low memory warning");
  }
}

// 發送 Ping_EX
void Ping_EX() {
  String message = String(Caller_Number) + "," + "ping" + "," + sendStr;
  if (client.ping()) {
    // Serial.println("Ping sent successfully");
    Serial.print("i");
  } else {
    Serial.println("Ping failed!!!");
  }
  client.send(message);
  lastPING = currentMillis;
  onMessage_time = lastPING;  // 重置 onMessage 計時器
}


void GetRunTimeStats() {
  // 獲取系統中任務的數量
  UBaseType_t taskCount = uxTaskGetNumberOfTasks();
  TaskStatus_t *taskStatusArray = (TaskStatus_t *)pvPortMalloc(taskCount * sizeof(TaskStatus_t));

  if (taskStatusArray != NULL) {
    // 獲取任務狀態信息
    UBaseType_t copiedTaskCount = uxTaskGetSystemState(taskStatusArray, taskCount, NULL);

    for (UBaseType_t i = 0; i < copiedTaskCount; i++) {
      Serial.printf("Task: %s, State: %d, RunTime: %lu\n",
                    taskStatusArray[i].pcTaskName,
                    taskStatusArray[i].eCurrentState,
                    taskStatusArray[i].ulRunTimeCounter);
    }

    // 釋放內存
    vPortFree(taskStatusArray);
  } else {
    Serial.println("Failed to allocate memory for task status array!");
  }
}

void GetRunTimeStats_old() {
  char buffer[1024];  // 假設 buffer 大小為 1024
  vTaskGetRunTimeStats(buffer);
  // 將 buffer 轉換為字串
  String stats = String(buffer);
  // 使用換行符分割字串
  int start = 0;
  int end = stats.indexOf('\n');
  int count = 0;
  while (end != -1 && count < 3) {
    String line = stats.substring(start, end);
    // 找到百分比的位置
    int percentIndex = line.lastIndexOf('\t') + 1;
    String percentStr = line.substring(percentIndex);
    // 去掉百分比符號並轉換為整數
    percentStr.trim();
    percentStr.replace("%", "");
    int percent = percentStr.toInt();
    // 如果百分比大於等於 1，則打印該行並增加計數
    if (percent >= 1) {
      Serial.println(line);
      count++;
    }
    // 更新起始和結束位置
    start = end + 1;
    end = stats.indexOf('\n', start);
  }
}

void check_system() {
  GetRunTimeStats();
  calculateCPULoad();
  checkMemory();
  Serial.printf("InterruptCount:%lu, scanDisplayCount:%lu \n", InterruptCount, scanDisplayCount);
}

void calculateCPULoad() {
  for (int i = 0; i < portNUM_PROCESSORS; i++) {
    uint32_t idleDiff = idleCount[i] - idleCountLast[i];
    float load = (1.0f - (float)idleDiff / (float)(configTICK_RATE_HZ * 1.0)) * 100.0f;

    // 確保負載量不為負數且不超過 100%
    if (load < 0) load = 0;
    if (load > 100) load = 100;
    Serial.printf("Core %d Load: %.2f%%\n", i, load);

    idleCountLast[i] = idleCount[i];
  }
}

// 主循環
void loop() {
  static unsigned long lastCheck = 0;
  currentMillis = millis();

  // 定期檢查連接狀態
  if (currentMillis - lastCheck >= STATE_UPDATE_INTERVAL) {
    lastCheck = currentMillis;
    checkConnections();
  }

  // 處理 Caller 數字發送
  // currentMillis = millis();
  if (currentMillis - lastCheckNumber >= CHECK_NUMBER_INTERVAL) {
    lastCheckNumber = currentMillis;
    sendCallerNumber();
    // 檢查重置按鈕
    if (digitalRead(0) == 0) {
      Serial.println("IO0 button pressed");
    }
    vTaskDelay(pdMS_TO_TICKS(1));
  }

  // 發送 ping
  // currentMillis = millis();
  if (currentMillis - lastPING >= PING_INTERVAL) {
    lastPING = currentMillis;
    Ping_EX();
  }

  // 檢查 onMessage 超時
  // currentMillis = millis();  // 必須即時
  if ((onMessage_time != 0) && (currentMillis - onMessage_time >= ON_MESSAGE_TIMEOUT)) {
    if (WiFi.status() == WL_CONNECTED) {
      Serial.println("onMessage timeout, reconnecting WebSocket...");
      client.close();
      updateSystemState(STATE_WEBSOCKET_CONNECTING);
      connectToWebSocket();
      onMessage_time = currentMillis;  // 重置計時器
    }
  }

  if (currentMillis - lastPrintTime >= printInterval) {
    lastPrintTime = currentMillis;  // 更新上次印出訊息的時間
    Serial.println();               // 印出換行
    check_system();
  }

  if (currentMillis % 10 == 0)  // 10ms 執行一次
    vTaskDelay(pdMS_TO_TICKS(1));
}