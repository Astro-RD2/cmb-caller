#define VERSION "VB8_20251016_Test"

#include <WebSocketsClient.h>
#include <Arduino.h>
#include <WiFi.h>
#include <ArduinoOTA.h>
#include <WebServer.h>
#include <Preferences.h>
#include <ESPping.h>
#include <ArduinoJson.h>

#include "credentials.h"
#include "ma_Functions.h"  // VB8 相關函數

// === 版本與叫號 ===
#ifndef LOCAL_TEST
String Version = VERSION;
#else
String Version = String(VERSION) + " Local Test!";
#endif
String Caller_Number = "00000";
const char Caller_Prefix[] = "CMB";
char Caller_SSID[sizeof(Caller_Prefix) + sizeof(Caller_Number) - 1];

// === LED 腳位 ===
#define LED_RED 33
#define LED_GREEN 32
#define LED_BLUE 2
#define LED_PIN 2
#define BUTTON_PIN 0

// === 計時器 ===
const long WIFI_TIMEOUT = 7000;
const long STATE_UPDATE_INTERVAL = 500;
const long CHECK_NUMBER_INTERVAL = 50;
const long SEND_INTERVAL = 10;
const long STATUS_INTERVAL = 500;

// === 系統變數 ===
unsigned long currentMillis = millis();
unsigned long lastSendTime = 0;
String nowStr = "0";
String sendStr = "000";
String lastSendStr = sendStr;
String password;

// === WebSocket ===
WebSocketsClient webSocketClient;
bool WebSocket_init = false;
unsigned long websocket_connect_time = millis();
bool new_connect = false;
bool waitingResponse = false;
int retryValue;
bool retryMode = false;
const int retryTimeout = 5;

// === 緩衝區 ===
#define NUM_BUFFER_SIZE 60
int num_buffer[NUM_BUFFER_SIZE];
int num_head = 0;
int num_tail = 0;

// === Demo 模式 ===
bool demoState = false;
const long MIN_INTERVAL = 30000;
const long MAX_INTERVAL = 90000;

// === 系統狀態 ===
enum SystemState {
  STATE_INIT, STATE_WIFI_CONNECTING, STATE_WIFI_CONNECTED,
  STATE_WEBSOCKET_CONNECTING, STATE_WEBSOCKET_CONNECTED,
  STATE_ERROR, STATE_DEMO, STATE_TRANS, STATE_AP_STA, STATE_AP_STA_C
};
struct Status { SystemState state; unsigned long lastStateChange; String lastError; };
Status status;

// === LED 結構 ===
struct LedState { bool isOn; bool isBlinking; unsigned long onTime, offTime, lastToggle; };
struct LedConfig { LedState red, green; };
LedConfig ledConfigs[10];
TimerHandle_t redTimer, greenTimer;

#define MAX_NETWORKS 15
#define MAX_USER_NETWORKS 10
#define WEBSOCKET_PORT 81  // WebSocket 伺服器端口

// 合併後的網路清單 (RAM中)
WiFiNetwork wifiNetworks[MAX_NETWORKS];
uint8_t networkCount = 0;
Preferences preferences;
WebServer server(80);

struct ScannedNetwork { String ssid, bssid; int8_t rssi; int channel; String encryption; };
std::vector<ScannedNetwork> scannedNetworks;

const unsigned long SCAN_INTERVAL = 60 * 60 * 1000;
unsigned long lastScanTime = millis() - SCAN_INTERVAL;
bool isScanning = false;

// === AP 模式 ===
int AP_mode = 0;
int AP_mode_now = 0;

// === 伺服器設定 ===
// const int SERVER_COUNT = 1;
struct ServerConfig {
  const char* host; uint16_t port; bool useSSL;
};
ServerConfig servers[SERVER_COUNT] = {{"ws://your-server.com", 8080, false}};

// === 預設網路 ===
WiFiNetwork defaultNetworks[1] = {{0}};

//======================================================================
// **函數原型**
void updateSystemState(SystemState newState, const String& error = "");
void initLedConfigs();
void updateLEDState();
void blinkLED(TimerHandle_t xTimer);
void setupOTA();
void setupWebSocket();
void scanWiFiInBackground();
bool attemptWiFiConnect();
void setupAP();
void disableAP();
void handleRoot();
void handleAddHTTP();
void handleDeleteHTTP();
void handleAddManual();
void webSocketEvent(WStype_t type, uint8_t* payload, size_t length);
void onMessageCallback(const String& message);
void parseUpdateMessage(const String& msg);
void num_LED_dis(const String& message);
void VB8_Send(unsigned long num);
bool VB8_Recv();
void GetSendCallerNumber(unsigned long currentMillis);
void buffer_push(int value);
bool buffer_pop(int& value);
void sendBufferedData();
void sendWebSocketMessage(int value);
void check_auth();
void loadNetworks();
void saveNetworks();
void addNetwork(const char* ssid, const char* password);
void deleteNetwork(uint8_t idx);
String generateSuccessResponse(const String& action, const String& callerId);
void WiFi_reconnect();

//======================================================================
// **初始化 LED 配置**
void initLedConfigs() {
  ledConfigs[STATE_INIT].red = {true, false, 0, 0, 0}; ledConfigs[STATE_INIT].green = {false, false, 0, 0, 0};
  ledConfigs[STATE_WIFI_CONNECTING].red = {false, true, 100, 100, 0}; ledConfigs[STATE_WIFI_CONNECTING].green = {false, false, 0, 0, 0};
  ledConfigs[STATE_WIFI_CONNECTED].red = {true, false, 0, 0, 0}; ledConfigs[STATE_WIFI_CONNECTED].green = {false, false, 0, 0, 0};
  ledConfigs[STATE_WEBSOCKET_CONNECTING].red = {true, true, 750, 750, 0}; ledConfigs[STATE_WEBSOCKET_CONNECTING].green = {false, true, 750, 750, 0};
  ledConfigs[STATE_WEBSOCKET_CONNECTED].red = {false, false, 0, 0, 0}; ledConfigs[STATE_WEBSOCKET_CONNECTED].green = {true, false, 0, 0, 0};
  ledConfigs[STATE_ERROR].red = {true, false, 0, 0, 0}; ledConfigs[STATE_ERROR].green = {false, false, 0, 0, 0};
  ledConfigs[STATE_DEMO].red = {false, false, 0, 0, 0}; ledConfigs[STATE_DEMO].green = {true, true, 1900, 100, 0};
  ledConfigs[STATE_TRANS].red = {true, true, 100, 10000, 0}; ledConfigs[STATE_TRANS].green = {true, false, 0, 0, 0};
  ledConfigs[STATE_AP_STA].red = {true, true, 100, 400, 0}; ledConfigs[STATE_AP_STA].green = {false, true, 500, 500, 0};
  ledConfigs[STATE_AP_STA_C].red = {false, false, 0, 0, 0}; ledConfigs[STATE_AP_STA_C].green = {true, true, 500, 500, 0};
}

// **LED 更新**
void updateLEDState() {
  vTimerSetTimerID(redTimer, &ledConfigs[status.state].red);
  vTimerSetTimerID(greenTimer, &ledConfigs[status.state].green);
  currentMillis = millis();
  blinkLED(redTimer); blinkLED(greenTimer);
}

// **LED 閃爍**
void blinkLED(TimerHandle_t xTimer) {
  unsigned long now = millis();
  LedState* ledState = (LedState*)pvTimerGetTimerID(xTimer);
  int pin = (ledState == &ledConfigs[status.state].red ? LED_RED : LED_GREEN);
  
  if (ledState->isBlinking) {
    if (ledState->isOn && (now - ledState->lastToggle >= ledState->onTime)) {
      ledState->isOn = false; ledState->lastToggle = now; digitalWrite(pin, HIGH);
      if (pin == LED_RED) digitalWrite(LED_BLUE, HIGH);
    } else if (!ledState->isOn && (now - ledState->lastToggle >= ledState->offTime)) {
      ledState->isOn = true; ledState->lastToggle = now; digitalWrite(pin, LOW);
      if (pin == LED_RED) digitalWrite(LED_BLUE, LOW);
    }
  } else {
    digitalWrite(pin, ledState->isOn ? LOW : HIGH);
    if (pin == LED_RED) digitalWrite(LED_BLUE, ledState->isOn ? LOW : HIGH);
  }
}

// **系統狀態更新**
void updateSystemState(SystemState newState, const String& error) {
  if (newState == STATE_AP_STA && WiFi.status() == WL_CONNECTED) newState = STATE_AP_STA_C;
  status.state = newState; status.lastStateChange = currentMillis;
  if (error.length() > 0) status.lastError = error;
  updateLEDState();
}

// **OTA 設定**
void setupOTA() {
  ArduinoOTA.setHostname(savedData1.c_str());
  ArduinoOTA.onStart([]() { Serial.println("OTA Start"); });
  ArduinoOTA.onEnd([]() { Serial.println("OTA End"); });
  ArduinoOTA.onProgress([](unsigned int progress, unsigned int total) {
    Serial.printf("OTA Progress: %u%%\r", (progress / (total / 100)));
  });
  ArduinoOTA.onError([](ota_error_t error) { Serial.printf("OTA Error[%u]\n", error); });
  ArduinoOTA.begin();
}

// **WebSocket 事件**
void webSocketEvent(WStype_t type, uint8_t* payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED: 
      Serial.printf("WebSocket Disconnected! (%lu Sec)\n", (millis() - websocket_connect_time) / 1000);
      updateSystemState(STATE_ERROR, "WebSocket Disconnected");
      break;
    case WStype_CONNECTED: 
      Serial.printf("WebSocket Connected! (%lu ms)\n", millis() - websocket_connect_time);
      websocket_connect_time = millis(); new_connect = true;
      updateSystemState(STATE_WEBSOCKET_CONNECTED); break;
    case WStype_TEXT: 
      onMessageCallback(String((char*)payload)); break;
    case WStype_PING: Serial.print("I"); break;
    case WStype_PONG: Serial.print("O"); break;
  }
}

// **訊息處理**
void onMessageCallback(const String& message) {
  if (message == "pong") { Serial.print("B"); return; }
  updateSystemState(AP_mode == 1 ? STATE_AP_STA : STATE_WEBSOCKET_CONNECTED);
  Serial.println("接收: " + message);
  parseUpdateMessage(message);
}

void parseUpdateMessage(const String& msg) {
  String parts[4]; int count = 0, start = 0;
  while (count < 4 && start < msg.length()) {
    int end = msg.indexOf(',', start); if (end == -1) end = msg.length();
    parts[count++] = msg.substring(start, end); start = end + 1;
  }
  if (count == 4 && (parts[3] == "update" || parts[3] == "get")) {
    if ((millis() - websocket_connect_time >= 1000) || (parts[2] != sendStr && parts[2] != lastSendStr)) {
      Serial.printf("%s 資料變動:%s\n", parts[3], parts[2]);
      num_LED_dis(parts[2]);
    }
  }
}

// **VB8 顯示**
void num_LED_dis(const String& message) {
  nowStr = message; sendStr = message; lastSendStr = sendStr;
  VB8_Send(message.toInt());
}

// **VB8 發送**
void VB8_Send(unsigned long num) {
  if (num < 1000) ma_set_data(int(num));
}

// **VB8 接收**
bool VB8_Recv() {
  int b = ma_get_data();
  if (b >= 0) {
    Serial.println("[VB8] Rev: " + String(b));
    nowStr = String(b);
    return true;
  }
  return false;
}

// **數字處理**
void GetSendCallerNumber(unsigned long currentMillis) {
  if (currentMillis - lastCheckNumber < CHECK_NUMBER_INTERVAL) return;
  static unsigned long lastCheckNumber = 0; lastCheckNumber = currentMillis;
  
  if (VB8_Recv()) {
    client_send(nowStr);
    process_change_AP_mode(nowStr.toInt());
  }
}

// **緩衝區操作**
void IRAM_ATTR buffer_push(int value) {
  num_buffer[num_head] = value; num_head = (num_head + 1) % NUM_BUFFER_SIZE;
  if (num_head == num_tail) num_tail = (num_tail + 1) % NUM_BUFFER_SIZE;
}

bool buffer_pop(int& value) {
  if (num_head == num_tail) return false;
  value = num_buffer[num_tail]; num_tail = (num_tail + 1) % NUM_BUFFER_SIZE;
  return true;
}

// **發送緩衝資料**
void sendBufferedData() {
  if (WiFi.status() == WL_CONNECTED && webSocketClient.isConnected() && !waitingResponse) {
    int value;
    if (retryMode) {
      sendWebSocketMessage(retryValue); retryMode = false;
    } else if (buffer_pop(value)) {
      sendWebSocketMessage(value);
      if (buffer_size() == 0) {
        String msg = String(Caller_Number) + ",get";
        webSocketClient.sendTXT(msg);
      }
    }
  }
  checkResponse();
}

// **WebSocket 發送**
void sendWebSocketMessage(int value) {
  check_auth();
  String message = String(Caller_Number) + ",send," + String(value);
  if (webSocketClient.sendTXT(message)) {
    sendTime = millis(); waitingResponse = true;
    Serial.printf("傳送：%s ", message.c_str());
  } else {
    retryValue = value; retryMode = true; waitingResponse = false;
    webSocketClient.disconnect(); setupWebSocket();
  }
}

// **認證**
void check_auth() {
  if (new_connect) {
    new_connect = false;
    String msg = String(Caller_Number) + ",auth," + FPSTR(auth_password);
    webSocketClient.sendTXT(msg);
    delay(200);
    
    char bssid[18]; sprintf(bssid, "%02X:%02X:%02X:%02X:%02X:%02X", 
      WiFi.BSSID()[0], WiFi.BSSID()[1], WiFi.BSSID()[2], WiFi.BSSID()[3], WiFi.BSSID()[4], WiFi.BSSID()[5]);
    msg = String(Caller_Number) + ",info,'SSID:" + WiFi.SSID() + " ; Ver:" + Version + "'";
    webSocketClient.sendTXT(msg);
    delay(200);
    
    msg = String(Caller_Number) + ",get";
    webSocketClient.sendTXT(msg);
  }
}

// **WiFi 掃描**
void scanWiFiInBackground() {
  if (!isScanning && (millis() - lastScanTime) >= SCAN_INTERVAL) {
    WiFi.scanNetworks(true);
    isScanning = true; lastScanTime = millis();
  }
  if (isScanning) {
    int result = WiFi.scanComplete();
    if (result >= 0) {
      scannedNetworks.clear();
      for (int i = 0; i < result; i++) {
        ScannedNetwork net;
        net.ssid = WiFi.SSID(i); net.rssi = WiFi.RSSI(i);
        if (net.rssi >= -85 && !net.ssid.isEmpty()) scannedNetworks.push_back(net);
      }
      WiFi.scanDelete(); isScanning = false;
      Serial.printf("掃描完成，找到 %d 個網路\n", scannedNetworks.size());
    }
  }
}

// **WiFi 連接**
bool attemptWiFiConnect() {
  if (WiFi.status() == WL_CONNECTED) return true;
  
  updateSystemState(AP_mode == 1 ? STATE_AP_STA : STATE_WIFI_CONNECTING);
  for (uint8_t i = 0; i < networkCount; i++) {
    if (!wifiNetworks[i].enabled) continue;
    String ssid = wifiNetworks[i].ssid;
    
    bool signalOK = scannedNetworks.empty() || 
      std::any_of(scannedNetworks.begin(), scannedNetworks.end(), 
        [&](const ScannedNetwork& n){ return n.ssid == ssid && n.rssi >= -85; });
    
    if (signalOK) {
      WiFi.begin(wifiNetworks[i].ssid, wifiNetworks[i].password);
      unsigned long start = millis();
      while (WiFi.status() != WL_CONNECTED && millis() - start < WIFI_TIMEOUT) {
        server.handleClient(); GetSendCallerNumber(millis());
      }
      if (WiFi.status() == WL_CONNECTED) {
        Serial.printf("連線成功！%s %s\n", ssid.c_str(), WiFi.localIP().toString().c_str());
        digitalWrite(LED_PIN, HIGH); return true;
      }
    }
  }
  digitalWrite(LED_PIN, LOW); return false;
}

// **AP 模式**
void setupAP() { WiFi.softAP("CMB Caller", "88888888"); }
void disableAP() { WiFi.softAPdisconnect(true); }

// **Web 處理**
void handleRoot() {
  String html = "<h2>WiFi設定 - " + Caller_Number + "</h2>";
  html += "<form method='POST' action='/add_http'>";
  for (const auto& net : scannedNetworks) {
    html += "<input type='radio' name='ssid' value='" + net.ssid + "'> " + net.ssid + " (" + String(net.rssi) + "dBm)<br>";
  }
  html += "密碼: <input type='text' name='password'><br>";
  html += "<input type='submit' value='加入'></form>";
  server.send(200, "text/html", html);
  
  lastScanTime = millis() - SCAN_INTERVAL;  // 立即掃描
}

void handleAddHTTP() {
  if (server.method() == HTTP_POST) {
    String ssid = server.arg("ssid"), pass = server.arg("password");
    addNetwork(ssid.c_str(), pass.c_str());
    saveNetworks(); WiFi_reconnect();
  }
  server.sendHeader("Location", "/"); server.send(302);
}

void handleDeleteHTTP() {
  if (server.hasArg("idx")) deleteNetwork(server.arg("idx").toInt());
  server.sendHeader("Location", "/"); server.send(302);
}

void handleAddManual() {
  String html = "<h2>手動輸入</h2><form method='POST'>";
  html += "SSID: <input name='ssid'><br>密碼: <input name='password'><br>";
  html += "<input type='submit'></form><a href='/'>返回</a>";
  server.send(200, "text/html", html);
}

// **網路管理**
void loadNetworks() {
  preferences.begin("wifi-config", false);
  uint8_t count = preferences.getUChar("count", 0);
  for (uint8_t i = 0; i < count && i < MAX_NETWORKS; i++) {
    String prefix = "net" + String(i);
    String ssid = preferences.getString((prefix + "ssid").c_str(), "");
    if (ssid.length() > 0) {
      strncpy(wifiNetworks[networkCount].ssid, ssid.c_str(), 31);
      strncpy(wifiNetworks[networkCount].password, 
        preferences.getString((prefix + "pass").c_str(), "").c_str(), 63);
      wifiNetworks[networkCount].enabled = true;
      wifiNetworks[networkCount].isUserAdded = true; networkCount++;
    }
  }
  preferences.end();
}

void saveNetworks() {
  preferences.begin("wifi-config", false);
  uint8_t count = 0;
  for (uint8_t i = 0; i < networkCount; i++) 
    if (wifiNetworks[i].isUserAdded) count++;
  preferences.putUChar("count", count);
  
  uint8_t idx = 0;
  for (uint8_t i = 0; i < networkCount; i++) {
    if (wifiNetworks[i].isUserAdded) {
      String prefix = "net" + String(idx++);
      preferences.putString((prefix + "ssid").c_str(), wifiNetworks[i].ssid);
      preferences.putString((prefix + "pass").c_str(), wifiNetworks[i].password);
    }
  }
  preferences.end();
}

void addNetwork(const char* ssid, const char* password) {
  // 檢查重複
  for (uint8_t i = 0; i < networkCount; i++) 
    if (strcmp(wifiNetworks[i].ssid, ssid) == 0) {
      strncpy(wifiNetworks[i].password, password, 63); return;
    }
  
  // 新增到首位
  if (networkCount < MAX_NETWORKS) {
    for (uint8_t i = networkCount; i > 0; i--) wifiNetworks[i] = wifiNetworks[i-1];
    strncpy(wifiNetworks[0].ssid, ssid, 31); strncpy(wifiNetworks[0].password, password, 63);
    wifiNetworks[0].enabled = wifiNetworks[0].isUserAdded = true; networkCount++;
  }
}

void deleteNetwork(uint8_t idx) {
  uint8_t userIdx = 0, found = 255;
  for (uint8_t i = 0; i < networkCount; i++) {
    if (wifiNetworks[i].isUserAdded) {
      if (userIdx++ == idx) { found = i; break; }
    }
  }
  if (found != 255) {
    for (uint8_t i = found; i < networkCount - 1; i++) wifiNetworks[i] = wifiNetworks[i+1];
    networkCount--; saveNetworks();
  }
}

// **WebSocket 設定**
void setupWebSocket() {
  updateSystemState(STATE_WEBSOCKET_CONNECTING, "Connecting WebSocket...");
  for (int i = 0; i < SERVER_COUNT; i++) {
    webSocketClient.begin(servers[i].host, servers[i].port, "/");
    webSocketClient.onEvent(webSocketEvent);
    webSocketClient.setReconnectInterval(1000);
    
    unsigned long start = millis();
    while (millis() - start < 10000) {
      webSocketClient.loop();
      if (webSocketClient.isConnected()) {
        Serial.printf("WebSocket 連線成功！%s:%d\n", servers[i].host, servers[i].port);
        return;
      }
    }
    webSocketClient.disconnect();
  }
  Serial.println("所有伺服器連接失敗！");
}

// **WiFi 重連**
void WiFi_reconnect() {
  webSocketClient.disconnect(); delay(500);
  WiFi.disconnect(false, false);
}

// **回應檢查**
void checkResponse() {
  static unsigned long sendTime = 0;
  if (waitingResponse && (millis() - sendTime >= retryTimeout * 2000)) {
    waitingResponse = false; retryMode = true;
    Serial.println("回應超時，重試");
  }
}

// **Setup**
void setup() {
  Serial.begin(115200);
  delay(1000); Serial.println("=== VB8 叫號機啟動 ===");
  
  // 載入設定
  preferences.begin("storage", true);
  String savedData1 = preferences.getString("saved_data1", "z0000");
  Caller_Number = savedData1; preferences.end();
  
  // 初始化 SSID
  strcpy(Caller_SSID, Caller_Prefix); strcat(Caller_SSID, Caller_Number.c_str());
  strncpy(defaultNetworks[0].ssid, Caller_SSID, 31); strncpy(defaultNetworks[0].password, "88888888", 63);
  
  // LED + 按鈕
  pinMode(LED_RED, OUTPUT); pinMode(LED_GREEN, OUTPUT); pinMode(LED_BLUE, OUTPUT); pinMode(BUTTON_PIN, INPUT);
  initLedConfigs();
  
  // LED 計時器
  redTimer = xTimerCreate("Red", pdMS_TO_TICKS(100), pdTRUE, &ledConfigs[0].red, blinkLED);
  greenTimer = xTimerCreate("Green", pdMS_TO_TICKS(100), pdTRUE, &ledConfigs[0].green, blinkLED);
  xTimerStart(redTimer, 0); xTimerStart(greenTimer, 0);
  
  // WiFi + AP
  WiFi.mode(WIFI_AP_STA); setupAP(); delay(200); AP_mode = 0;
  loadNetworks(); addNetwork(Caller_SSID, "88888888"); saveNetworks();
  
  // OTA + Web
  setupOTA();
  server.on("/", handleRoot); server.on("/add_http", handleAddHTTP);
  server.on("/delete_http", handleDeleteHTTP); server.on("/add_manual", handleAddManual);
  server.begin();
  
  updateSystemState(STATE_WIFI_CONNECTING);
  Serial.println("Setup 完成！\n");
}

// **主循環 - VB8 版本**
void loop_VB8() {
  static unsigned long lastStatusTime = 0;
  currentMillis = millis();
  
  // WiFi 管理
  scanWiFiInBackground();
  if (!attemptWiFiConnect()) {
    if (millis() - lastStatusTime >= STATUS_INTERVAL) {
      lastStatusTime = millis(); Serial.print(" D");
    }
  } else {
    if (millis() - lastStatusTime >= STATUS_INTERVAL) {
      lastStatusTime = millis(); Serial.print(" C");
    }
    if (!WebSocket_init) { WebSocket_init = true; setupWebSocket(); }
    webSocketClient.loop();
  }
  
  // VB8 數字處理
  GetSendCallerNumber(currentMillis);
  
  // 緩衝發送
  if (currentMillis - lastSendTime >= SEND_INTERVAL) {
    lastSendTime = currentMillis; sendBufferedData();
  }
  
  // 服務器處理
  server.handleClient();
  ArduinoOTA.handle();
  
  delay(10);
}