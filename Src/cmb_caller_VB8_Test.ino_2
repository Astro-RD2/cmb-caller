#define VERSION "VB8_20251016_Test"

#include <WebSocketsClient.h>
#include <Arduino.h>
#include <WiFi.h>
#include <WebServer.h>
#include <Preferences.h>
#include <ArduinoJson.h>
#include "credentials.h"
#include "ma_Functions.h"

String Version = VERSION;
String Caller_Number = "00000";
#define LED_RED 33
#define LED_GREEN 32
#define LED_BLUE 2

const long WIFI_TIMEOUT = 7000;
const long CHECK_NUMBER_INTERVAL = 50;
const unsigned long SEND_INTERVAL = 10;
const int RETRY_COUNT = 1;

String nowStr = "0";
String sendStr = "000";
String lastSendStr = sendStr;
volatile unsigned long onMessage_time = 0;
unsigned long lastSendTime = 0;
volatile unsigned long currentMillis = millis();

const char Caller_Prefix[] = "CMB";
char Caller_SSID[sizeof(Caller_Prefix) + sizeof(Caller_Number) - 1];

WebSocketsClient webSocketClient;
Preferences preferences;
WebServer server(80);

#define MAX_NETWORKS 15
WiFiNetwork wifiNetworks[MAX_NETWORKS];
uint8_t networkCount = 0;
String ssid, password;
bool new_connect = false;
int ping_EX_no_reply_count = 0;
int sendPing_fail = 0;
unsigned long websocket_connect_time = millis();
bool WebSocket_init = false;
int AP_mode = 0;

#define NUM_BUFFER_SIZE 60
int num_buffer[NUM_BUFFER_SIZE];
int num_head = 0;
int num_tail = 0;
bool waitingResponse = false;
int retryValue;
bool retryMode = false;
const int retryTimeout = 5;
unsigned long sendTime;

#define TX2 17
#define RX2 16

const unsigned long SCAN_INTERVAL = 60 * 60 * 1000;
const unsigned long SCAN_MIN_INTERVAL = 30000;
unsigned long lastScanTime = millis() - SCAN_INTERVAL;
unsigned long lastScanTimeRun = millis() - SCAN_MIN_INTERVAL;
const int MIN_ACCEPTABLE_RSSI = -85;
const unsigned long CONNECT_RETRY_DELAY = 1000;
unsigned long lastConnectAttempt = millis() - CONNECT_RETRY_DELAY - 1000;
bool isScanning = false;
unsigned long scanStartTime = 0;

struct ScannedNetwork {
  String ssid;
  String bssid;
  int8_t rssi;
  int channel;
  String encryption;
};
std::vector<ScannedNetwork> scannedNetworks;

IPAddress apIP;
IPAddress LocalIP;
bool Maint_mode = true;

String savedData1 = "";        // å­˜å„²è³‡æ–™ 1
String savedData2 = "";        // å­˜å„²è³‡æ–™ 2
String savedData3 = "";        // å­˜å„²è³‡æ–™ 3
volatile bool NullId = false;
unsigned long startTime = 0;
const unsigned long expireMinutes = 10;
unsigned long expireTime = expireMinutes * 60 * 1000;

#define STATUS_INTERVAL 500
static unsigned long lastCheck = 0;
unsigned long lastDisconnectTime = 0;
const unsigned long RECONNECT_DELAY = 1000;

enum SystemState {
  STATE_INIT,
  STATE_WIFI_CONNECTING,
  STATE_WIFI_CONNECTED,
  STATE_WEBSOCKET_CONNECTING,
  STATE_WEBSOCKET_CONNECTED,
  STATE_ERROR,
  STATE_AP_STA,
  STATE_AP_STA_C
};

struct Status {
  SystemState state;
  unsigned long lastStateChange;
  String lastError;
  String currentSSID;
} status;

struct LedState {
  bool isOn;
  bool isBlinking;
  unsigned long onTime;
  unsigned long offTime;
  unsigned long lastToggle;
};

struct LedConfig {
  LedState red;
  LedState green;
} ledConfigs[9];

TimerHandle_t redTimer;
TimerHandle_t greenTimer;

// å‡½æ•¸åŸå‹
void updateSystemState(SystemState newState, const String& error = "");
void GetSendCallerNumber(unsigned long currentMillis);
void initLedConfigs();
void updateLEDState();
void blinkLED(TimerHandle_t xTimer);
void setupAP();
void disableAP();
void loadNetworks();
void mergeDefaultNetworks();
void addNetwork(const char* ssid, const char* password);
void saveNetworks();
String getWiFiStatusJSON(const String& callerId, const String& uuid = "");
String scanWiFiListJSON(const String& callerId, const String& uuid = "");
String getWiFiProfilesJSON(const String& callerId, const String& uuid = "");
String generateSuccessResponse(const String& action, const String& callerId, const String& uuid = "");
void scanWiFiInBackground();
bool isAcceptableSignal(const String& ssid);
int8_t getRSSI(const String& ssid);
void attemptWiFiConnect();
void setupWebSocket();
void webSocketEvent(WStype_t type, uint8_t* payload, size_t length);
void onMessageCallback(const String& message);
void parseUpdateMessage(const String& msg);
void executeWifiCommand(const String& payload);
void add_profile(const char* ssid, const char* password);
void WiFi_reconnect();
bool webSocketClient_sendTXT(String& message);
void check_auth();
void buffer_push(int value);
bool buffer_pop(int& value);
void sendBufferedData();
void sendWebSocketMessage(int value);
void checkResponse();
void VB8_Send(unsigned long num);
bool VB8_Recv();
void num_LED_dis(const String& message);
void change_AP_mode();
void process_change_AP_mode(int code);
void IRAM_ATTR client_send(const String& message);

// ====== å·¥å…·å‡½å¼ ======
uint8_t min(uint8_t a, uint8_t b) {
  return (a < b) ? a : b;
}

// ====== ç¶²è·¯ç®¡ç† ======
void loadNetworks() {
  preferences.begin("wifi-config", false);
  uint8_t savedCount = min(preferences.getUChar("count", 0), 10);
  for (int i = 0; i < savedCount; i++) {
    String prefix = "net" + String(i);
    String ssid_str = preferences.getString((prefix + "ssid").c_str(), "");
    String pass = preferences.getString((prefix + "pass").c_str(), "");
    if (ssid_str.length() > 0 && networkCount < MAX_NETWORKS) {
      strncpy(wifiNetworks[networkCount].ssid, ssid_str.c_str(), 31);
      strncpy(wifiNetworks[networkCount].password, pass.c_str(), 63);
      wifiNetworks[networkCount].enabled = true;
      wifiNetworks[networkCount].rssi = 0;
      wifiNetworks[networkCount].isUserAdded = true;
      networkCount++;
    }
  }
  preferences.end();
}

void saveNetworks() {
  preferences.begin("wifi-config", false);
  uint8_t userCount = 0;
  for (int i = 0; i < networkCount; i++) {
    if (wifiNetworks[i].isUserAdded) userCount++;
  }
  preferences.putUChar("count", userCount);
  uint8_t savedIndex = 0;
  for (int i = 0; i < networkCount && savedIndex < userCount; i++) {
    if (wifiNetworks[i].isUserAdded) {
      String prefix = "net" + String(savedIndex);
      preferences.putString((prefix + "ssid").c_str(), String(wifiNetworks[i].ssid));
      preferences.putString((prefix + "pass").c_str(), String(wifiNetworks[i].password));
      savedIndex++;
    }
  }
  preferences.end();
}

void addNetwork(const char* ssid_in, const char* password_in) {
  for (uint8_t i = 0; i < networkCount; i++) {
    if (strcmp(wifiNetworks[i].ssid, ssid_in) == 0) {
      strncpy(wifiNetworks[i].password, password_in, 63);
      wifiNetworks[i].password[63] = 0;
      wifiNetworks[i].isUserAdded = true;
      if (wifiNetworks[i].isUserAdded) {
        WiFiNetwork temp = wifiNetworks[i];
        for (uint8_t j = i; j > 0; j--) {
          wifiNetworks[j] = wifiNetworks[j - 1];
        }
        wifiNetworks[0] = temp;
      }
      return;
    }
  }
  if (networkCount < MAX_NETWORKS) {
    for (uint8_t i = networkCount; i > 0; i--) {
      wifiNetworks[i] = wifiNetworks[i - 1];
    }
    strncpy(wifiNetworks[0].ssid, ssid_in, 31);
    wifiNetworks[0].ssid[31] = 0;
    strncpy(wifiNetworks[0].password, password_in, 63);
    wifiNetworks[0].password[63] = 0;
    wifiNetworks[0].enabled = true;
    wifiNetworks[0].rssi = 0;
    wifiNetworks[0].isUserAdded = true;
    networkCount++;
  }
}

void mergeDefaultNetworks() {
  for (uint8_t i = 0; i < defaultNetworkCount; i++) {
    bool exists = false;
    for (uint8_t j = 0; j < networkCount; j++) {
      if (strcmp(wifiNetworks[j].ssid, defaultNetworks[i].ssid) == 0) {
        exists = true;
        break;
      }
    }
    if (!exists && networkCount < MAX_NETWORKS) {
      wifiNetworks[networkCount] = defaultNetworks[i];
      networkCount++;
    }
  }
}

void setupAP() {
  WiFi.softAP("CMB Caller", "88888888");
  updateSystemState(STATE_AP_STA);
  Serial.print("AP å•Ÿå‹•ï¼ŒIPï¼š");
  Serial.println(WiFi.softAPIP());
}

void disableAP() {
  WiFi.softAPdisconnect(true);
  updateSystemState(STATE_WIFI_CONNECTING);
}



// ====== WiFi æƒæèˆ‡é€£æ¥ ======
const char* getEncryptionType(wifi_auth_mode_t type) {
  switch (type) {
    case WIFI_AUTH_OPEN: return "Open";
    case WIFI_AUTH_WPA_PSK: return "WPA";
    case WIFI_AUTH_WPA2_PSK: return "WPA2";
    case WIFI_AUTH_WPA_WPA2_PSK: return "WPA/WPA2";
    default: return "Unknown";
  }
}

void scanWiFiInBackground() {
  if (!isScanning && (millis() - lastScanTime) >= SCAN_INTERVAL) {
    for (int retry = 0; retry < 3; retry++) {
      if (millis() - lastScanTimeRun <= SCAN_MIN_INTERVAL) {
        int delay = (SCAN_MIN_INTERVAL - (millis() - lastScanTimeRun));
        lastScanTime = millis() - SCAN_INTERVAL + delay;
        return;
      }
      int scanResult = WiFi.scanNetworks(true, false, false, 100);
      if (scanResult == WIFI_SCAN_RUNNING) {
        isScanning = true;
        scanStartTime = millis();
        lastScanTime = millis();
        lastScanTimeRun = lastScanTime;
        break;
      } else if (retry < 2) {
        WiFi.scanDelete();
        delay(500 * (retry + 1));
      } else {
        isScanning = false;
      }
    }
  }

  if (isScanning) {
    int scanStatus = WiFi.scanComplete();
    if (scanStatus == WIFI_SCAN_RUNNING) {
      if (millis() - scanStartTime > 10000) {
        WiFi.scanDelete();
        isScanning = false;
      }
      return;
    }
    if (scanStatus < 0) {
      isScanning = false;
      return;
    }
    Serial.printf("æƒæå®Œæˆï¼Œæ‰¾åˆ° %d å€‹ç¶²è·¯\n", scanStatus);
    scannedNetworks.clear();
    for (int i = 0; i < scanStatus; ++i) {
      ScannedNetwork network;
      network.ssid = WiFi.SSID(i);
      network.bssid = WiFi.BSSIDstr(i);
      network.rssi = WiFi.RSSI(i);
      network.channel = WiFi.channel(i);
      network.encryption = getEncryptionType(WiFi.encryptionType(i));
      bool isDuplicate = false;
      bool isWeakSignal = (network.rssi < MIN_ACCEPTABLE_RSSI);
      for (const auto& existing : scannedNetworks) {
        if (existing.ssid == network.ssid) {
          isDuplicate = true;
          break;
        }
      }
      if (!isDuplicate && !isWeakSignal && !network.ssid.isEmpty()) {
        scannedNetworks.push_back(network);
      }
    }
    WiFi.scanDelete();
    isScanning = false;
  }
}

bool isAcceptableSignal(const String& ssid) {
  if (scannedNetworks.size() == 0) return true;
  for (const auto& network : scannedNetworks) {
    if (network.ssid == ssid) {
      return network.rssi >= MIN_ACCEPTABLE_RSSI;
    }
  }
  return false;
}

int8_t getRSSI(const String& ssid) {
  for (const auto& network : scannedNetworks) {
    if (network.ssid == ssid) return network.rssi;
  }
  return -127;
}

void attemptWiFiConnect() {
  const uint8_t MAX_ATTEMPTS = 1;
  static unsigned long lastStatusTime = 0;
  if (WiFi.status() != WL_CONNECTED && millis() - lastConnectAttempt >= CONNECT_RETRY_DELAY) {
    updateSystemState(AP_mode == 1 ? STATE_AP_STA : STATE_WIFI_CONNECTING);
    if (isScanning) {
      if (millis() - lastStatusTime >= STATUS_INTERVAL) {
        lastStatusTime = millis();
        Serial.print(" sc");
      }
      return;
    }
    Serial.printf("\né€£ç·š Wi-Fi...\n");
    for (uint8_t attemptCount = 1; attemptCount <= MAX_ATTEMPTS; attemptCount++) {
      for (uint8_t i = 0; i < networkCount; i++) {
        if (!wifiNetworks[i].enabled) continue;
        String currentSSID = String(wifiNetworks[i].ssid);
        if (isAcceptableSignal(currentSSID)) {
          int8_t rssi = getRSSI(currentSSID);
          Serial.printf("æ¸¬è©¦ç¶²è·¯ #%d: %s (%d dBm)\n", i + 1, currentSSID.c_str(), rssi);
          WiFi.begin(wifiNetworks[i].ssid, wifiNetworks[i].password);
          password = wifiNetworks[i].password;
          unsigned long startAttempt = millis();
          unsigned long lastBlink = 0;
          while (WiFi.status() != WL_CONNECTED && millis() - startAttempt < WIFI_TIMEOUT) {
            if (millis() - lastBlink >= 500) {
              lastBlink = millis();
              Serial.print(".");
            }
            server.handleClient();
            GetSendCallerNumber(millis());
          }
          if (WiFi.status() == WL_CONNECTED) {
            Serial.printf("\né€£ç·šæˆåŠŸï¼(%s,%s,%s)\n", Caller_Number.c_str(), wifiNetworks[i].ssid, WiFi.localIP().toString().c_str());
            digitalWrite(LED_BLUE, HIGH);
            lastConnectAttempt = millis();
            return;
          } else {
            digitalWrite(LED_BLUE, LOW);
            WiFi.disconnect(true);
          }
        }
      }
      if (WiFi.status() != WL_CONNECTED) {
        digitalWrite(LED_BLUE, LOW);
        Serial.println("\nå…¨éƒ¨é€£ç·šå¤±æ•—,è¨­å®š WiFi ç«‹å³æƒæ!!");
        lastScanTime = millis() - SCAN_INTERVAL;
        lastScanTimeRun = lastScanTime - SCAN_MIN_INTERVAL;
        return;
      }
    }
    lastConnectAttempt = millis();
  }
}

// ====== LED æ§åˆ¶ ======
void initLedConfigs() {
  ledConfigs[STATE_INIT].red = { true, false, 0, 0, 0 };
  ledConfigs[STATE_INIT].green = { false, false, 0, 0, 0 };
  ledConfigs[STATE_WIFI_CONNECTING].red = { false, true, 100, 100, 0 };
  ledConfigs[STATE_WIFI_CONNECTING].green = { false, false, 0, 0, 0 };
  ledConfigs[STATE_WIFI_CONNECTED].red = { true, false, 0, 0, 0 };
  ledConfigs[STATE_WIFI_CONNECTED].green = { false, false, 0, 0, 0 };
  ledConfigs[STATE_WEBSOCKET_CONNECTING].red = { true, true, 750, 750, 0 };
  ledConfigs[STATE_WEBSOCKET_CONNECTING].green = { false, true, 750, 750, 0 };
  ledConfigs[STATE_WEBSOCKET_CONNECTED].red = { false, false, 0, 0, 0 };
  ledConfigs[STATE_WEBSOCKET_CONNECTED].green = { true, false, 0, 0, 0 };
  ledConfigs[STATE_ERROR].red = { false, false, 0, 0, 0 };
  ledConfigs[STATE_ERROR].green = { false, false, 0, 0, 0 };
  ledConfigs[STATE_AP_STA].red = { true, true, 100, 400, 0 };
  ledConfigs[STATE_AP_STA].green = { false, true, 500, 500, 0 };
  ledConfigs[STATE_AP_STA_C].red = { false, false, 0, 0, 0 };
  ledConfigs[STATE_AP_STA_C].green = { true, true, 500, 500, 0 };
}

void updateLEDState() {
  LedState* redState = &ledConfigs[status.state].red;
  LedState* greenState = &ledConfigs[status.state].green;
  vTimerSetTimerID(redTimer, redState);
  vTimerSetTimerID(greenTimer, greenState);
  currentMillis = millis();
  blinkLED(redTimer);
  blinkLED(greenTimer);
}

void updateSystemState(SystemState newState, const String& error) {
  if (newState == STATE_AP_STA && WiFi.status() == WL_CONNECTED) {
    newState = STATE_AP_STA_C;
  }
  Serial.printf(" _S%d ", newState);
  if (error.length() > 0) {
    status.lastError = error;
    Serial.println(error);
  }
  status.lastStateChange = currentMillis;
  status.state = newState;
  updateLEDState();
}

void blinkLED(TimerHandle_t xTimer) {
  unsigned long now = millis();
  LedState* ledState = (LedState*)pvTimerGetTimerID(xTimer);
  int selectedLED = (ledState == &ledConfigs[status.state].red ? LED_RED : LED_GREEN);

  if (ledState->isBlinking) {
    if (ledState->isOn && (now - ledState->lastToggle >= ledState->onTime)) {
      ledState->isOn = false;
      ledState->lastToggle = now;
      digitalWrite(selectedLED, HIGH);
      if (selectedLED == LED_RED) digitalWrite(LED_BLUE, HIGH);
    } else if (!ledState->isOn && (now - ledState->lastToggle >= ledState->offTime)) {
      ledState->isOn = true;
      ledState->lastToggle = now;
      digitalWrite(selectedLED, LOW);
      if (selectedLED == LED_RED) digitalWrite(LED_BLUE, LOW);
    }
  } else {
    int status_val = (ledState->isOn ? LOW : HIGH);
    digitalWrite(selectedLED, status_val);
    if (selectedLED == LED_RED) digitalWrite(LED_BLUE, status_val);
  }
}

unsigned int cldNum = 1;            // CLDç•¶å‰ç·¨è™Ÿ(0-999)
unsigned long lastCheckNumber = 0;  // ä¸Šæ¬¡æª¢æŸ¥æ•¸å­—æ™‚é–“

// ====== VB8 ç›¸é—œ (ä¿ç•™æ ¸å¿ƒ) ======
void VB8_Send(unsigned long num) {
  if (num < 1000) {
    bool ok = ma_set_data(int(num));
    cldNum = num;
  }
}

bool VB8_Recv() {
  static unsigned long last_VB8_KB_read = millis();
  if ((millis() - last_VB8_KB_read) >= 100) {
    Serial.print("VB8_Recv é–“éš”æ™‚é–“éå¤§?");
    Serial.println((millis() - last_VB8_KB_read));
  }
  last_VB8_KB_read = millis();
  int b = ma_get_data();
  if (b >= 0) {
    Serial.println("[MSG_VB8] VB8 rev data " + String(b));
    nowStr = String(b);
    return true;
  }
  return false;
}

bool bypassLast = false;

void num_LED_dis(const String& message) {  // LED é¡¯ç¤ºå³è¨­å®šæœ€æ–°å€¼
  // Serial.printf("Set nowStr: '%s' -> '%s'\n", nowStr, message);
  nowStr = message;  // !!!@@@
   nowStrDemo = nowStr;
  if (bypassLast) {
    lastSendStr = "000";
    bypassLast = false;
  } else {
    lastSendStr = sendStr;
  }
  sendStr = message;  //
  VB8_Send(message.toInt());
}

void GetSendCallerNumber(unsigned long currentMillis) {
  if (currentMillis - lastCheckNumber < CHECK_NUMBER_INTERVAL) return;
  static unsigned long lastCheckNumber = 0;
  lastCheckNumber = currentMillis;
  bool get_num = VB8_Recv();
  if (get_num) {
    client_send(nowStr);
    lastSendStr = sendStr;
    sendStr = nowStr;
    onMessage_time = currentMillis;
    process_change_AP_mode(sendStr.toInt());
  }
}

// ====== ç·©è¡å€èˆ‡ç™¼é€ ======
void IRAM_ATTR client_send(const String& message) {
  buffer_push(message.toInt());
}

void IRAM_ATTR buffer_push(int value) {
  num_buffer[num_head] = value;
  num_head = (num_head + 1) % NUM_BUFFER_SIZE;
  if (num_head == num_tail) {
    num_tail = (num_tail + 1) % NUM_BUFFER_SIZE;
  }
}

bool buffer_pop(int& value) {
  if (num_head == num_tail) return false;
  value = num_buffer[num_tail];
  num_tail = (num_tail + 1) % NUM_BUFFER_SIZE;
  return true;
}

void sendBufferedData() {
  static unsigned long bufferSendTime = millis();
  if (WiFi.status() == WL_CONNECTED && webSocketClient.isConnected() && !waitingResponse) {
    int value;
    if (retryMode) {
      value = retryValue;
      sendWebSocketMessage(value);
      bufferSendTime = millis();
      retryMode = false;
    } else if ((millis() - bufferSendTime > 500) && buffer_pop(value)) {
      sendWebSocketMessage(value);
      bufferSendTime = millis();
    }
  }
  checkResponse();
}

void sendWebSocketMessage(int value) {
  String message = String(Caller_Number) + ",send," + String(value);
  updateSystemState(STATE_AP_STA);
  bool success = webSocketClient_sendTXT(message);
  if (success) {
    updateSystemState(STATE_AP_STA_C);
    sendTime = millis();
    waitingResponse = true;
    retryMode = false;
    Serial.printf(" å‚³é€ï¼š%s ", message.c_str());
  } else {
    retryValue = value;
    retryMode = true;
    waitingResponse = false;
    webSocketClient.disconnect();
    vTaskDelay(pdMS_TO_TICKS(500));
    setupWebSocket();
  }
}

void checkResponse() {
  if (waitingResponse && (millis() - sendTime >= retryTimeout * 2000)) {
    waitingResponse = false;
    retryMode = true;
    retryValue = num_buffer[(num_tail == 0) ? NUM_BUFFER_SIZE - 1 : num_tail - 1];
    Serial.println("å›æ‡‰è¶…æ™‚ï¼Œå•Ÿå‹•é‡è©¦æ©Ÿåˆ¶");
    webSocketClient.disconnect();
    delay(500);
    setupWebSocket();
  }
}

// ====== WebSocket ======
void setupWebSocket() {
  updateSystemState(STATE_WEBSOCKET_CONNECTING);
  for (int i = 0; i < SERVER_COUNT; i++) {
    const char* host = servers[i].host;
    uint16_t port = servers[i].port;
    bool useSSL = servers[i].useSSL;
    if (useSSL) {
      webSocketClient.beginSSL(host, port, "/");
    } else {
      webSocketClient.begin(host, port, "/");
    }
    webSocketClient.onEvent(webSocketEvent);
    webSocketClient.setReconnectInterval(1);
    unsigned long startTime = millis();
    while (millis() - startTime < 10000) {
      if (WiFi.status() != WL_CONNECTED) return;
      webSocketClient.loop();
      if (webSocketClient.isConnected()) {
        Serial.printf("[ç‹€æ…‹] é€£æ¥æˆåŠŸï¼(%s:%d)\n", host, port);
        updateSystemState(STATE_WEBSOCKET_CONNECTED);
        return;
      }
      vTaskDelay(pdMS_TO_TICKS(100));
    }
    webSocketClient.disconnect();
  }
  updateSystemState(STATE_WEBSOCKET_CONNECTING);
}

void webSocketEvent(WStype_t type, uint8_t* payload, size_t length) {
  switch (type) {
    case WStype_DISCONNECTED:
      Serial.printf("\nWebSocket Disconnected! (%lu Sec)\n", (millis() - websocket_connect_time) / 1000);
      updateSystemState(STATE_ERROR);
      break;
    case WStype_CONNECTED:
      Serial.printf("\nWebSocket Connected!(%lu ms)\n", millis() - websocket_connect_time);
      websocket_connect_time = millis();
      new_connect = true;
      updateSystemState(STATE_WEBSOCKET_CONNECTED);
      break;
    case WStype_TEXT:
      onMessageCallback(String((char*)payload));
      break;
    case WStype_PING:
      Serial.print("Io");
      break;
    case WStype_PONG:
      Serial.print("O");
      ping_EX_no_reply_count = 0;
      break;
  }
}

bool webSocketClient_sendTXT(String& message) {
  Serial.print("[WebSocket ç™¼é€] ");
  Serial.println(message);
  webSocketClient.sendTXT(message);
  return true;
}

void check_auth() {
  static bool auth_sent = false;
  if (new_connect && !auth_sent) {
    new_connect = false;
    auth_sent = true;
    String caller_password = FPSTR(auth_password);
    String message = String(Caller_Number) + ",auth," + caller_password;
    updateSystemState(STATE_AP_STA);
    webSocketClient_sendTXT(message);
    vTaskDelay(pdMS_TO_TICKS(200));

    char bssid[18];
    sprintf(bssid, "%02X:%02X:%02X:%02X:%02X:%02X", WiFi.BSSID()[0], WiFi.BSSID()[1],
            WiFi.BSSID()[2], WiFi.BSSID()[3], WiFi.BSSID()[4], WiFi.BSSID()[5]);
    message = String(Caller_Number) + ",info,'SSID:" + String(WiFi.SSID()) + " ; RSSI:" + String(WiFi.RSSI()) + "dBm ; BSSID:" + String(bssid) + " ; IP:" + WiFi.localIP().toString() + " ; Ver:" + String(Version) + "'";
    updateSystemState(STATE_AP_STA);
    webSocketClient_sendTXT(message);
    vTaskDelay(pdMS_TO_TICKS(200));

    message = String(Caller_Number) + ",get";
    Serial.println("æŸ¥è©¢æœ€æ–°å«è™Ÿè™Ÿç¢¼!");
    webSocketClient_sendTXT(message);
    vTaskDelay(pdMS_TO_TICKS(200));
  }
}

void onMessageCallback(const String& message) {
  onMessage_time = 0;
  if (message == "pong") {
    Serial.print("B");
    return;
  }
  updateSystemState(STATE_AP_STA_C);
  Serial.println("æ¥æ”¶: " + message);
  if (message.startsWith("OK,")) {
    waitingResponse = false;
  }
  parseUpdateMessage(message);
}

void parseUpdateMessage(const String& msg) {  // é›²ç«¯æ¥æ”¶
  // å…ˆå˜—è©¦è§£æç‚º JSON æ ¼å¼
  StaticJsonDocument<200> doc;
  DeserializationError error = deserializeJson(doc, msg);

  if (!error) {
    // å¦‚æœæ˜¯æœ‰æ•ˆçš„ JSONï¼Œæª¢æŸ¥æ˜¯å¦æœ‰ "action" æ¬„ä½
    if (doc.containsKey("action")) {
      String action = doc["action"].as<String>();
      if (action.startsWith("wifi_")) {
        // åŸ·è¡Œè™•ç† wifi_ é–‹é ­æŒ‡ä»¤çš„å‡½æ•¸
        executeWifiCommand(msg);
        return;
      }
    }
  }

  String parts[4];
  int count = 0;
  int start = 0;
  while (count < 4 && start < msg.length()) {
    int end = msg.indexOf(',', start);
    if (end == -1) end = msg.length();
    parts[count++] = msg.substring(start, end);
    start = end + 1;
  }
  // if (count == 4 && parts[3] == "update" && parts[2] != sendStr) {
  //   Serial.printf("æ›´æ–°å€¼:%s, old sendStr:%s \n", parts[2], sendStr);
  //   // æ”¹åªéœ€é¡¯ç¤º !!!@@@
  //   // send_and_dis(parts[2]);
  //   num_LED_dis(parts[2]);
  // }
  if (count == 4 && (parts[3] == "update" || parts[3] == "get")) {
    Serial.printf("Websocket å·²é€£ç·šæ™‚é–“:%lu\n", millis() - websocket_connect_time);
    bypassLast = false;
    if (((millis() - websocket_connect_time) >= 1000) || (parts[2] != sendStr && parts[2] != lastSendStr)) {  // æ–°è¼¸å…¥ OR æœ‰è®Šå‹•
      if ((millis() - websocket_connect_time) < 1000) {                                                       // Web æ”¹å‹• Server ä¸Šå«è™Ÿè³‡æ–™
        bypassLast = true;
        Serial.printf("bypassLast = true\n");
      }
      Serial.printf("%s   è³‡æ–™è®Šå‹•:%s, old sendStr:%s,%s \n", parts[3], parts[2], lastSendStr, sendStr);  //
      num_LED_dis(parts[2]);
    } else {
      Serial.printf("%s è³‡æ–™æœªè®Šå‹•:%s, old sendStr:%s,%s \n", parts[3], parts[2], lastSendStr, sendStr);  //
      // delay(500);                                                                                         // å¤§æ–¼ 0.4ç§’ ï¼Œ ä»¥é˜²æ­¢ Server å›å‚³.   ~~~~~~~~~
    }
  }
}

// void parseUpdateMessage(const String& msg) {
//   String parts[4];
//   int count = 0, start = 0;
//   while (count < 4 && start < msg.length()) {
//     int end = msg.indexOf(',', start);
//     if (end == -1) end = msg.length();
//     parts[count++] = msg.substring(start, end);
//     start = end + 1;
//   }
//   if (count == 4 && (parts[3] == "update" || parts[3] == "get")) {
//     Serial.printf("%s è³‡æ–™è®Šå‹•:%s\n", parts[3].c_str(), parts[2].c_str());
//     num_LED_dis(parts[2]);
//   }
// }

void executeWifiCommand(const String& payload) {
  DynamicJsonDocument doc(2048);
  deserializeJson(doc, payload);
  String action = doc["action"] | "";
  String callerId = doc["caller_id"] | "";
  String uuid = doc["uuid"] | "";

  if (action == "wifi_get_status") {
    String response = getWiFiStatusJSON(callerId, uuid);
    webSocketClient_sendTXT(response);
    lastScanTime = millis() - SCAN_INTERVAL;
  } else if (action == "wifi_scan_list") {
    String response = scanWiFiListJSON(callerId, uuid);
    webSocketClient_sendTXT(response);
  } else if (action == "wifi_get_profiles") {
    String response = getWiFiProfilesJSON(callerId, uuid);
    webSocketClient_sendTXT(response);
  } else if (action == "wifi_add_profile") {
    JsonObject data = doc["data"];
    String ssid_str = data["ssid"];
    String pass = data["password"];
    if (ssid_str.length() > 0 && ssid_str.length() <= 31 && pass.length() <= 63) {
      add_profile(ssid_str.c_str(), pass.c_str());
      String response = generateSuccessResponse(action, callerId, uuid);
      webSocketClient_sendTXT(response);
      WiFi_reconnect();
    }
  }
}

// ====== JSON å›æ‡‰ ======
String getWiFiStatusJSON(const String& callerId, const String& uuid) {
  DynamicJsonDocument jsonDoc(256);
  jsonDoc["action"] = "wifi_get_status";
  jsonDoc["caller_id"] = callerId;
  if (!uuid.isEmpty()) jsonDoc["uuid"] = uuid;
  jsonDoc["result"] = "OK";
  JsonObject data = jsonDoc.createNestedObject("data");
  data["wifi_connected"] = (WiFi.status() == WL_CONNECTED);
  if (WiFi.status() == WL_CONNECTED) {
    data["current_ssid"] = WiFi.SSID();
    data["password"] = password;
    data["ip_address"] = WiFi.localIP().toString();
    data["rssi"] = WiFi.RSSI();
  }
  String jsonString;
  serializeJson(jsonDoc, jsonString);
  return jsonString;
}

String scanWiFiListJSON(const String& callerId, const String& uuid) {
  JsonDocument jsonDoc = DynamicJsonDocument(2048);
  jsonDoc["action"] = "wifi_scan_list";
  jsonDoc["caller_id"] = callerId;
  if (!uuid.isEmpty()) jsonDoc["uuid"] = uuid;
  jsonDoc["result"] = "OK";
  JsonObject data = jsonDoc.createNestedObject("data");
  JsonArray networks = data.createNestedArray("networks");
  for (const auto& network : scannedNetworks) {
    JsonObject net = networks.createNestedObject();
    net["ssid"] = network.ssid;
    net["bssid"] = network.bssid;
    net["rssi"] = network.rssi;
    net["channel"] = network.channel;
    net["encryption"] = network.encryption;
  }
  String jsonString;
  serializeJson(jsonDoc, jsonString);
  return jsonString;
}

String getWiFiProfilesJSON(const String& callerId, const String& uuid) {
  DynamicJsonDocument jsonDoc(1024);
  jsonDoc["action"] = "wifi_get_profiles";
  jsonDoc["caller_id"] = callerId;
  if (!uuid.isEmpty()) jsonDoc["uuid"] = uuid;
  jsonDoc["result"] = "OK";
  JsonObject data = jsonDoc.createNestedObject("data");
  JsonArray credentials = data.createNestedArray("credentials");
  uint8_t userNetworkIndex = 0;
  for (uint8_t i = 0; i < networkCount; i++) {
    if (wifiNetworks[i].isUserAdded) {
      JsonObject credential = credentials.createNestedObject();
      credential["ssid"] = wifiNetworks[i].ssid;
      credential["password"] = wifiNetworks[i].password;
      credential["priority"] = userNetworkIndex + 1;
      userNetworkIndex++;
    }
  }
  String jsonString;
  serializeJson(jsonDoc, jsonString);
  return jsonString;
}

String generateSuccessResponse(const String& action, const String& callerId, const String& uuid) {
  DynamicJsonDocument jsonDoc(128);
  jsonDoc["action"] = action;
  jsonDoc["caller_id"] = callerId;
  if (!uuid.isEmpty()) jsonDoc["uuid"] = uuid;
  jsonDoc["result"] = "OK";
  String jsonString;
  serializeJson(jsonDoc, jsonString);
  return jsonString;
}

void add_profile(const char* ssid, const char* password) {
  addNetwork(ssid, password);
  saveNetworks();
}

void WiFi_reconnect() {
  delay(500);
  webSocketClient.disconnect();
  delay(500);
  WiFi.disconnect(false, false);
}

// ====== AP æ¨¡å¼åˆ‡æ› ======
int AP_mode_now = 1;
const int CODE1_PART1 = 159, CODE1_PART2 = 357;
const int CODE2_PART1 = 357, CODE2_PART2 = 159;
enum WifiProcessStatus { IDLE,
                         WAITING_FOR_SECOND_CODE,
                         ACTIVE_MODE };
WifiProcessStatus currentState = IDLE;
unsigned long stateEnterTime = 0;
int firstCode = 0;

void change_AP_mode() {
  if (AP_mode_now == AP_mode) return;
  Serial.printf("åˆ‡æ› AP åˆ°æ¨¡å¼ %i\n", AP_mode);
  AP_mode_now = AP_mode;
  if (AP_mode == 1) {
    setupAP();
  } else {
    disableAP();
  }
}

void process_change_AP_mode(int code) {
  switch (currentState) {
    case IDLE:
      if (code == CODE1_PART1 || code == CODE2_PART1) {
        firstCode = code;
        currentState = WAITING_FOR_SECOND_CODE;
        stateEnterTime = millis();
      }
      break;
    case WAITING_FOR_SECOND_CODE:
      if (millis() - stateEnterTime > 30000) {
        currentState = IDLE;
        break;
      }
      if ((firstCode == CODE1_PART1 && code == CODE1_PART2) || (firstCode == CODE2_PART1 && code == CODE2_PART2)) {
        AP_mode = (firstCode == CODE1_PART1) ? 1 : 0;
        currentState = (firstCode == CODE1_PART1) ? ACTIVE_MODE : IDLE;
        Serial.printf("AP_mode %s by code\n", AP_mode ? "enabled" : "disabled");
        change_AP_mode();
      } else {
        currentState = IDLE;
      }
      break;
    case ACTIVE_MODE:
      if (code == CODE2_PART1) {
        firstCode = code;
        currentState = WAITING_FOR_SECOND_CODE;
        stateEnterTime = millis();
      }
      break;
  }
}

void cmb_handleRoot() {
  // æª¢æŸ¥æ˜¯å¦è¶…éå¤±æ•ˆæ™‚é–“
  if (!Maint_mode) {
    server.send(403, "text/plain; charset=UTF-8", "åŠŸèƒ½å·²å¤±æ•ˆ! (" + String(__func__) + ")");
    Serial.printf("åŠŸèƒ½å·²å¤±æ•ˆ(%s)\n", __func__);
    return;
  }
  String html = "<!DOCTYPE html><html><head>"
                "<meta charset='UTF-8'>"
                "<title>ESP32 Flash å­˜å„²</title>"
                "<style>"
                "label {display: inline-block; width: 100px; text-align: right; margin-right: 10px;}"
                "</style></head><body>"
                "<h2>ESP32 Flash è³‡æ–™å­˜å„²</h2>"
                "<form action='/cmb_store' method='POST'>"
                "<div><label for='data1'>ID:</label>"
                "<input type='text' id='data1' name='data1' value='"
                + savedData1 + "'></div>"
                               "<div><label for='data2'>PASSWORD:</label>"
                               "<input type='text' id='data2' name='data2' value='"
                + savedData2 + "'></div>"
                               "<div><label for='data3'>data3:</label>"
                               "<input type='text' id='data3' name='data3' value='"
                + savedData3 + "'></div>"
                               "<div style='margin-left: 110px;'><input type='submit' value='å„²å­˜'></div></form><br>"
                               "<a href='/cmb_retrieve'>ğŸ“„ è®€å–å­˜å„²çš„è³‡æ–™</a><br>"
                               "</body></html>";
  server.send(200, "text/html; charset=UTF-8", html);
  Serial.println("cmb_handleRoot");
}

// **å­˜å„²è³‡æ–™**
void handleStore() {
  if (!Maint_mode) {
    server.send(403, "text/plain; charset=UTF-8", "åŠŸèƒ½å·²å¤±æ•ˆ! (" + String(__func__) + ")");
    Serial.printf("åŠŸèƒ½å·²å¤±æ•ˆ(%s)\n", __func__);
    return;
  }
  preferences.begin("storage", false);

  String response = "";
  if (server.hasArg("data1")) {
    String data1 = server.arg("data1");
    preferences.putString("saved_data1", data1);
    response += "è³‡æ–™ 1 å·²å­˜å„²: " + data1 + "\n";
  }

  if (server.hasArg("data2")) {
    String data2 = server.arg("data2");
    preferences.putString("saved_data2", data2);
    response += "è³‡æ–™ 2 å·²å­˜å„²: " + data2 + "\n";
  }

  if (server.hasArg("data3")) {
    String data3 = server.arg("data3");
    preferences.putString("saved_data3", data3);
    response += "è³‡æ–™ 3 å·²å­˜å„²: " + data3 + "\n";
  }

  preferences.end();

  if (response == "") {
    server.send(400, "text/plain; charset=UTF-8", "éŒ¯èª¤: ç¼ºå°‘ data åƒæ•¸");
    Serial.println("éŒ¯èª¤: ç¼ºå°‘ data åƒæ•¸");
  } else {
    server.send(200, "text/plain; charset=UTF-8", response);
  }
  Serial.println("ç³»çµ±å°‡åœ¨1ç§’å¾Œé‡å•Ÿ...");
  delay(1000);
  ESP.restart();
}

// **è®€å– Flash ä¸­çš„è³‡æ–™**
void handleRetrieve() {
  // æª¢æŸ¥æ˜¯å¦è¶…éå¤±æ•ˆæ™‚é–“
  if (!Maint_mode) {
    server.send(403, "text/plain; charset=UTF-8", "åŠŸèƒ½å·²å¤±æ•ˆ! (" + String(__func__) + ")");
    Serial.printf("åŠŸèƒ½å·²å¤±æ•ˆ(%s)\n", __func__);
    return;
  }
  preferences.begin("storage", true);
  savedData1 = preferences.getString("saved_data1", "");
  savedData2 = preferences.getString("saved_data2", "");
  savedData3 = preferences.getString("saved_data3", "");
  preferences.end();
  String response = "      ID: " + savedData1 + "\n" + "PASSWORD: " + savedData2 + "\n" + "   data3: " + savedData3;
  // String response1 = "ID: " + savedData1;
  server.send(200, "text/plain; charset=UTF-8", response);
  // Serial.println(response1);
}

// ====== åˆå§‹åŒ– ======
void setup() {
  Serial.begin(115200);
  startTime = millis();
  delay(250);
  Serial.println("----------------------------------");

  preferences.begin("storage", true);
  savedData1 = preferences.getString("saved_data1", "z0000");
  savedData2 = preferences.getString("saved_data2", "88888888");
  preferences.end();

  if (savedData1 == "z0000") NullId = true;
  Caller_Number = savedData1;
  strcpy(Caller_SSID, Caller_Prefix);
  strcat(Caller_SSID, Caller_Number.c_str());
  strncpy(defaultNetworks[0].ssid, Caller_SSID, sizeof(defaultNetworks[0].ssid) - 1);
  strncpy(defaultNetworks[0].password, "88888888", sizeof(defaultNetworks[0].password) - 1);

  Serial.printf("cmb_caller Ver:%s, Caller Number %s\n", Version.c_str(), Caller_Number.c_str());

  pinMode(LED_RED, OUTPUT);
  pinMode(LED_GREEN, OUTPUT);
  pinMode(LED_BLUE, OUTPUT);
  initLedConfigs();

  redTimer = xTimerCreate("RedLEDTimer", pdMS_TO_TICKS(100), pdTRUE, &ledConfigs[STATE_INIT].red, blinkLED);
  greenTimer = xTimerCreate("GreenLEDTimer", pdMS_TO_TICKS(100), pdTRUE, &ledConfigs[STATE_INIT].green, blinkLED);
  xTimerStart(redTimer, 0);
  xTimerStart(greenTimer, 0);

  updateSystemState(STATE_INIT);

  WiFi.mode(WIFI_AP_STA);
  setupAP();
  delay(200);
  AP_mode = 0;

  WiFi.setSleep(false);
  loadNetworks();
  mergeDefaultNetworks();

  server.on("/cmb", HTTP_GET, cmb_handleRoot);
  server.on("/cmb_store", HTTP_POST, handleStore);
  server.on("/cmb_retrieve", HTTP_GET, handleRetrieve);
  // server.on("/cmb_status", HTTP_GET, handleStatus);

  // server.on("/", handleRoot);
  // server.on("/add_http", handleAddHTTP);
  // server.on("/delete_http", handleDeleteHTTP);

  server.begin();

  updateSystemState(STATE_WIFI_CONNECTING);
  Serial.println("Setup finish!\n----------------------------------");

  setup_x();
}

// ====== ä¿ç•™çš„æ ¸å¿ƒ loop_VB8 ======
void loop_VB8() {
  static unsigned long lastStatusTime = 0;
  currentMillis = millis();

  scanWiFiInBackground();
  attemptWiFiConnect();

  if (WiFi.status() == WL_CONNECTED) {
    if (!WebSocket_init) {
      WebSocket_init = true;
      setupWebSocket();
    }
    webSocketClient.loop();
  }

  server.handleClient();
  GetSendCallerNumber(currentMillis);

  if (currentMillis - lastSendTime >= SEND_INTERVAL) {
    lastSendTime = currentMillis;
    sendBufferedData();
  }

  if (WiFi.status() != WL_CONNECTED) {
    if (millis() - lastStatusTime >= STATUS_INTERVAL) {
      lastStatusTime = millis();
      Serial.print(" D");
    }
    if (lastDisconnectTime == 0) {
      lastDisconnectTime = millis();
      digitalWrite(LED_BLUE, LOW);
      WiFi.disconnect(false, false);
      if (scannedNetworks.size() <= 0) {
        lastScanTime = millis() - SCAN_INTERVAL;
        lastScanTimeRun = lastScanTime - SCAN_MIN_INTERVAL;
      } else {
        lastScanTime = millis() - SCAN_INTERVAL + 5000;
      }
    } else if (millis() - lastDisconnectTime > RECONNECT_DELAY) {
      lastDisconnectTime = millis();
    }
  } else {
    if (millis() - lastStatusTime >= STATUS_INTERVAL) {
      lastStatusTime = millis();
      Serial.print(webSocketClient.isConnected() ? " C" : " Cd");
    }
    lastDisconnectTime = 0;
    digitalWrite(LED_BLUE, HIGH);
    check_auth();
  }
}

void loop() {
  delay(100);
}